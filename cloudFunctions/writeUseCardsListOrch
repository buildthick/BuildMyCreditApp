const functions = require('firebase-functions');
const admin = require('firebase-admin');
// Do NOT call admin.initializeApp()

exports.writeUseCardsListOrch = functions.region('us-central1').https.onCall(
  async (data, context) => {
    if (!context.auth || !context.auth.uid) return;

    const db = admin.firestore();
    const uid = context.auth.uid;
    const userRef = db.doc(`users/${uid}`);

    // ---------- cycleId (optional, from orchestrator) ----------
    let cycleId = null;
    if (data) {
      if (data.cycleID != null) {
        cycleId = typeof data.cycleID === 'string'
          ? data.cycleID
          : String(data.cycleID);
      } else if (data.cycleId != null) {
        cycleId = typeof data.cycleId === 'string'
          ? data.cycleId
          : String(data.cycleId);
      }
    }
    // If cycleId is null => standalone/testing: no cycleId field is written.
    // -------------------------------------------------

    // Helpers
    const now = new Date();
    const toJsDate = (ts) => {
      if (!ts) return null;
      if (typeof ts.toDate === 'function') return ts.toDate();
      if (ts._seconds != null) return new Date(ts._seconds * 1000);
      return null;
    };
    const monthDiffCalendar = (from, to) => {
      const y = to.getFullYear() - from.getFullYear();
      const m = to.getMonth() - from.getMonth();
      let diff = y * 12 + m;
      if (to.getDate() < from.getDate()) diff -= 1;
      return Math.max(0, diff);
    };
    const olderThanCalendarMonths = (d, months) => {
      if (!(d instanceof Date)) return false;
      const thresh = new Date(now);
      thresh.setMonth(thresh.getMonth() - months);
      return d.getTime() < thresh.getTime();
    };

    // 1) Pull ALL cards for this user (no composite index needed)
    const allCardsSnap = await db.collection('user_credit_cards')
      .where('userRef', '==', userRef)
      .get();

    // Keep tracking sets/arrays
    const allIds = new Set();
    const openCards = [];

    allCardsSnap.forEach(doc => {
      allIds.add(doc.id);
      const c = doc.data() || {};
      if (c.isOpen === true) {
        openCards.push({ id: doc.id, data: c });
      }
    });

    // 2) Count of open cards with balance > 0  (DOUBLE field)
    const cardsWithBalanceCount = openCards.reduce((acc, { data }) => {
      const bal = Number(data.totalBalance ?? 0);
      return acc + (bal > 0 ? 1 : 0);
    }, 0);

    // 3) Build candidate list (include 0-balance cards), then exclude annual fee / CFA
    const candidates = openCards.filter(({ data }) => !(data.isCFA === true || data.isAnnualFee === true));

    // 4) Compute useAge + 5-month risk + rank
    const items = candidates.map(({ id, data }) => {
      const dlu = toJsDate(data.dateLastUsed);

      let useAgeMonths, useAgeDays, useAgeMs;
      if (dlu) {
        useAgeMonths = monthDiffCalendar(dlu, now);
        useAgeDays = Math.floor((now - dlu) / (24 * 60 * 60 * 1000));
        useAgeMs = now - dlu;
      } else {
        // Spec: missing dateLastUsed => useAge = 1 month
        useAgeMonths = 1;
        useAgeDays = 30;
        useAgeMs = 30 * 24 * 60 * 60 * 1000;
      }

      const isOlderThan5M = dlu ? olderThanCalendarMonths(dlu, 5) : (useAgeMonths > 5);
      const atAgeRiskOrAZEOorBoth =
        (isOlderThan5M && cardsWithBalanceCount === 0) ||
        (isOlderThan5M && cardsWithBalanceCount < 2);

      return {
        id,
        raw: data,
        useAgeMonths,
        useAgeDays,
        useAgeMs,
        atAgeRiskOrAZEOorBoth
      };
    });

    items.sort((a, b) => b.useAgeMs - a.useAgeMs);
    items.forEach((it, i) => { it.rank = i + 1; });

    // 5) Upserts (idempotent, same doc id as source)
    const batch = db.batch();

    for (const it of items) {
      const src = it.raw;
      const targetRef = db.collection('user_use_cards_list').doc(it.id);
      const docRefCard = db.collection('user_credit_cards').doc(it.id);

      const basePayload = {
        // New counter instead of AZEO
        cardsWithBalanceCount: Number(cardsWithBalanceCount),

        // Rank/age + condition
        rank: it.rank,
        useAgeMonths: it.useAgeMonths,
        useAgeDays: it.useAgeDays,
        atAgeRiskOrAZEOorBoth: it.atAgeRiskOrAZEOorBoth,

        // Mirrors for UI
        lender: src.lender ?? null,
        commercialName: src.commercialName ?? null,
        creditLimit: src.creditLimit ?? null,
        apr: src.apr ?? null,
        totalBalance: src.totalBalance ?? null,
        dayOfMonthDue: src.dayOfMonthDue ?? null,
        minimumPayment: src.minimumPayment ?? null,
        rewardType: src.rewardType ?? null,
        isOpen: src.isOpen ?? null,
        isCFA: src.isCFA ?? null,
        isAnnualFee: src.isAnnualFee ?? null,

        // Dates (preserve if present)
        dateLastUsed: src.dateLastUsed ?? null,
        dateIssued: src.dateIssued ?? null,

        // Refs
        userRef,
        DocRefCard: docRefCard,

        // Bookkeeping
        created_time: admin.firestore.FieldValue.serverTimestamp(),
      };

      if (cycleId) {
        basePayload.cycleId = cycleId; // tag use-card rec with cycleId when orchestrated
      }

      batch.set(targetRef, basePayload, { merge: true });
    }

    // 6) Cleanup: delete only orphans for this user
    const existingListSnap = await db.collection('user_use_cards_list')
      .where('userRef', '==', userRef)
      .get();

    existingListSnap.forEach(doc => {
      if (!allIds.has(doc.id)) {
        batch.delete(doc.ref);
      }
    });

    await batch.commit();

    return {
      ok: true,
      stats: {
        open_count: openCards.length,
        cards_with_balance_count: cardsWithBalanceCount,
        written: items.length
      },
    };
  }
);
