// This version correctly computes Current_Value where
// AccountType_Variation = Current accounts / lates AND
// AccountType_Variation = Revolving % of total
// AccountType_Variation = Utilization
// AccountType_Variation = Number of CFA or AF Cards with 0 Balance
    // NOTE: this^ returns null if no CFA/AFs exist, and 0 when at least 1 exists but has 0 balance

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.computeUserConstraintCurrentValues = functions.region('us-central1').https.onCall(
  async (data, context) => {
    // 1) Auth check
    const uid = context.auth && context.auth.uid;
    if (!uid) {
      throw new functions.https.HttpsError('unauthenticated', 'Must be signed in.');
    }
    const db = admin.firestore();

    try {
      // --- 1) Current Accounts / Lates ratio ---
      const currentSnap = await db
        .collection('user_stocks_conso')
        .where('stock', 'in', ['user_credit_cards', 'user_loans'])
        .where('isCurrent', '==', true)
        .get();
      const numberCurrentAccounts = currentSnap.size;

      const latesSnap = await db
        .collection('user_stocks_conso')
        .where('stock', 'in', [
          'user_credit_cards_late_payments',
          'user_loans_late_payments',
          'user_collections_3rd_party'
        ])
        .get();
      const numberLates = latesSnap.size;

      const rawCAL = numberLates === 0
        ? numberCurrentAccounts
        : numberCurrentAccounts / numberLates;
      const calRatio = parseFloat(rawCAL.toFixed(4));

      // --- 2) Revolving % of total ---
      const revSnap = await db
        .collection('user_stocks_conso')
        .where('subStock', '==', 'Revolving')
        .get();
      let totalRevolving = 0;
      let revDocs = [];
      revSnap.forEach(doc => {
        const s = doc.data().stock;
        if (s !== 'user_hard_pulls' && s !== 'user_credit_cards_late_payments') {
          totalRevolving++;
          revDocs.push(doc);
        }
      });

      const instSnap = await db
        .collection('user_stocks_conso')
        .where('subStock', '==', 'Installment')
        .get();
      let totalInstallment = 0;
      instSnap.forEach(doc => {
        const s = doc.data().stock;
        if (s !== 'user_hard_pulls' && s !== 'user_loans_late_payments') {
          totalInstallment++;
        }
      });

      const totalAccounts = totalRevolving + totalInstallment;
      const rawRevPct = totalAccounts === 0
        ? 0
        : totalRevolving / totalAccounts;
      const revPct = parseFloat(rawRevPct.toFixed(4));

      // --- 3) Utilization (balance ÷ credit limit) ---
      let totalRevolvingCreditLimit = 0;
      let totalBalance = 0;
      revDocs.forEach(doc => {
        const d = doc.data();
        totalRevolvingCreditLimit += (d.creditLimit || 0);
        totalBalance += (d.amountsOwed || 0);
      });

      const rawUtil = totalRevolvingCreditLimit === 0
        ? 0
        : totalBalance / totalRevolvingCreditLimit;
      const utilization = parseFloat(rawUtil.toFixed(4));

      // --- 4) Number of CFA or AF Cards with 0 Balance ---
      // Count ALL Annual Fee cards
      const allAFSnap = await db
        .collection('user_stocks_conso')
        .where('stock', '==', 'user_credit_cards')
        .where('isAnnualFee', '==', true)
        .get();
      const totalAF = allAFSnap.size;

      // Count ALL CFA cards
      const allCFASnap = await db
        .collection('user_stocks_conso')
        .where('stock', '==', 'user_credit_cards')
        .where('isCFA', '==', true)
        .get();
      const totalCFA = allCFASnap.size;

      const totalCFA_AF = totalAF + totalCFA;

      // Count zero‐balance among those
      const zeroBalanceSnap = await db
        .collection('user_stocks_conso')
        .where('stock', '==', 'user_credit_cards')
        .where('amountsOwed', '==', 0)
        .get();
      let numZeroBalanceCFAorAF = 0;
      zeroBalanceSnap.forEach(doc => {
        const d = doc.data();
        if (d.isAnnualFee === true || d.isCFA === true) {
          numZeroBalanceCFAorAF++;
        }
      });

      // Decide what to write: null if no AF/CFA cards at all
      const valueToWrite = totalCFA_AF === 0
        ? null
        : numZeroBalanceCFAorAF;

      // --- Prepare batch updates ---
      const batch = db.batch();

      // Update Current Accounts / Lates
      const calConstraints = await db
        .collection('user_plan_target_constraints')
        .where('AccountType_Variation', '==', 'Current accounts / lates')
        .get();
      calConstraints.forEach(doc => {
        if (doc.data().Current_Value !== calRatio) {
          batch.set(
            db.collection('user_plan_target_constraints').doc(doc.id),
            { Current_Value: calRatio },
            { merge: true }
          );
        }
      });

      // Update Revolving % of total
      const revConstraints = await db
        .collection('user_plan_target_constraints')
        .where('AccountType_Variation', '==', 'Revolving % of total')
        .get();
      revConstraints.forEach(doc => {
        if (doc.data().Current_Value !== revPct) {
          batch.set(
            db.collection('user_plan_target_constraints').doc(doc.id),
            { Current_Value: revPct },
            { merge: true }
          );
        }
      });

      // Update Utilization
      const utilConstraints = await db
        .collection('user_plan_target_constraints')
        .where('AccountType_Variation', '==', 'Utilization')
        .get();
      utilConstraints.forEach(doc => {
        if (doc.data().Current_Value !== utilization) {
          batch.set(
            db.collection('user_plan_target_constraints').doc(doc.id),
            { Current_Value: utilization },
            { merge: true }
          );
        }
      });

      // Update Number of CFA or AF Cards with 0 Balance
      const zeroBalConstraints = await db
        .collection('user_plan_target_constraints')
        .where(
          'AccountType_Variation',
          '==',
          'Number of CFA or AF Cards with 0 Balance'
        )
        .get();
      zeroBalConstraints.forEach(doc => {
        const old = doc.data().Current_Value;
        if (old !== valueToWrite) {
          batch.set(
            db.collection('user_plan_target_constraints').doc(doc.id),
            { Current_Value: valueToWrite },
            { merge: true }
          );
        }
      });

      // Commit all updates
      await batch.commit();

      return {
        success: true,
        numberCurrentAccounts,
        numberLates,
        calRatio,
        totalRevolving,
        totalInstallment,
        totalAccounts,
        revPct,
        utilization,
        totalAF,
        totalCFA,
        totalCFA_AF,
        numZeroBalanceCFAorAF,
        writtenValue: valueToWrite
      };
    } catch (err) {
      console.error('Error computing current values:', err);
      throw new functions.https.HttpsError(
        'internal',
        err.message || 'Unknown error'
      );
    }
  }
);
