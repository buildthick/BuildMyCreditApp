// This version correctly computes Current_Value where
// AccountType_Variation = Current accounts / lates AND
// AccountType_Variation = Revolving % of total
// AccountType_Variation = Utilization

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.computeUserConstraintCurrentValues = functions.region('us-central1').https.onCall(
  async (data, context) => {
    // 1) Auth check
    const uid = context.auth && context.auth.uid;
    if (!uid) {
      throw new functions.https.HttpsError('unauthenticated', 'Must be signed in.');
    }
    const db = admin.firestore();

    try {
      // --- Compute Current Accounts / Lates ratio ---
      const currentSnap = await db
        .collection('user_stocks_conso')
        .where('stock', 'in', ['user_credit_cards', 'user_loans'])
        .where('isCurrent', '==', true)
        .get();
      const numberCurrentAccounts = currentSnap.size;

      const latesSnap = await db
        .collection('user_stocks_conso')
        .where('stock', 'in', [
          'user_credit_cards_late_payments',
          'user_loans_late_payments',
          'user_collections_3rd_party'
        ])
        .get();
      const numberLates = latesSnap.size;

      const rawCAL = numberLates === 0
        ? numberCurrentAccounts
        : numberCurrentAccounts / numberLates;
      const calRatio = parseFloat(rawCAL.toFixed(4));

      // --- Compute Revolving % of total ---
      const revSnap = await db
        .collection('user_stocks_conso')
        .where('subStock', '==', 'Revolving')
        .get();
      let totalRevolving = 0;
      let revDocs = [];
      revSnap.forEach(doc => {
        const s = doc.data().stock;
        if (s !== 'user_hard_pulls' && s !== 'user_credit_cards_late_payments') {
          totalRevolving++;
          revDocs.push(doc);
        }
      });

      const instSnap = await db
        .collection('user_stocks_conso')
        .where('subStock', '==', 'Installment')
        .get();
      let totalInstallment = 0;
      instSnap.forEach(doc => {
        const s = doc.data().stock;
        if (s !== 'user_hard_pulls' && s !== 'user_loans_late_payments') {
          totalInstallment++;
        }
      });

      const totalAccounts = totalRevolving + totalInstallment;
      const rawRevPct = totalAccounts === 0
        ? 0
        : totalRevolving / totalAccounts;
      const revPct = parseFloat(rawRevPct.toFixed(4));

      // --- Compute Utilization ---
      // Use same revDocs for revolving accounts
      let totalRevolvingCreditLimit = 0;
      let totalBalance = 0;
      revDocs.forEach(doc => {
        const data = doc.data();
        totalRevolvingCreditLimit += (data.creditLimit || 0);
        totalBalance += (data.amountsOwed || 0);
      });

      const rawUtil = totalRevolvingCreditLimit === 0
        ? 0
        : totalBalance / totalRevolvingCreditLimit;
      const utilization = parseFloat(rawUtil.toFixed(4));

      // --- Prepare batch updates ---
      const batch = db.batch();

      // Update Current Accounts / Lates
      const calConstraints = await db
        .collection('user_plan_target_constraints')
        .where('AccountType_Variation', '==', 'Current accounts / lates')
        .get();
      calConstraints.forEach(doc => {
        if (doc.data().Current_Value !== calRatio) {
          batch.set(
            db.collection('user_plan_target_constraints').doc(doc.id),
            { Current_Value: calRatio },
            { merge: true }
          );
        }
      });

      // Update Revolving % of total
      const revConstraints = await db
        .collection('user_plan_target_constraints')
        .where('AccountType_Variation', '==', 'Revolving % of total')
        .get();
      revConstraints.forEach(doc => {
        if (doc.data().Current_Value !== revPct) {
          batch.set(
            db.collection('user_plan_target_constraints').doc(doc.id),
            { Current_Value: revPct },
            { merge: true }
          );
        }
      });

      // Update Utilization
      const utilConstraints = await db
        .collection('user_plan_target_constraints')
        .where('AccountType_Variation', '==', 'Utilization')
        .get();
      utilConstraints.forEach(doc => {
        if (doc.data().Current_Value !== utilization) {
          batch.set(
            db.collection('user_plan_target_constraints').doc(doc.id),
            { Current_Value: utilization },
            { merge: true }
          );
        }
      });

      // Commit all updates
      await batch.commit();

      return {
        success: true,
        numberCurrentAccounts,
        numberLates,
        calRatio,
        totalRevolving,
        totalInstallment,
        totalAccounts,
        revPct,
        totalRevolvingCreditLimit,
        totalBalance,
        utilization
      };
    } catch (err) {
      console.error('Error computing current values:', err);
      throw new functions.https.HttpsError(
        'internal',
        err.message || 'Unknown error'
      );
    }
  }
);
