// This version correctly computes Current_Value where
// AccountType_Variation = Current accounts / lates AND
// AccountType_Variation = Revolving % of total
// AccountType_Variation = Utilization
// AccountType_Variation = Number of CFA or AF Cards with 0 Balance
    // NOTE: this^ returns null if no CFA/AFs exist, and 0 when at least 1 exists but has 0 balance
// AccountType_Variation = Minimum 1 loan
// AccountType_Variation = Minimum 1 card

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.computeUserConstraintCurrentValues = functions.region('us-central1').https.onCall(
  async (data, context) => {
    // 1) Auth check
    const uid = context.auth && context.auth.uid;
    if (!uid) {
      throw new functions.https.HttpsError('unauthenticated','Must be signed in.');
    }
    const db = admin.firestore();

    try {
      // --- 1) Current Accounts / Lates ratio ---
      const currentSnap = await db
        .collection('user_stocks_conso')
        .where('stock','in',['user_credit_cards','user_loans'])
        .where('isCurrent','==',true)
        .get();
      const numberCurrentAccounts = currentSnap.size;

      const latesSnap = await db
        .collection('user_stocks_conso')
        .where('stock','in',[
          'user_credit_cards_late_payments',
          'user_loans_late_payments',
          'user_collections_3rd_party'
        ])
        .get();
      const numberLates = latesSnap.size;

      const rawCAL = numberLates===0
        ? numberCurrentAccounts
        : numberCurrentAccounts/numberLates;
      const calRatio = parseFloat(rawCAL.toFixed(4));

      // --- 2) Revolving % of total ---
      const revSnap = await db
        .collection('user_stocks_conso')
        .where('subStock','==','Revolving')
        .get();
      let totalRevolving=0, revDocs=[];
      revSnap.forEach(doc=>{
        const s=doc.data().stock;
        if(s!=='user_hard_pulls'&&s!=='user_credit_cards_late_payments'){
          totalRevolving++;
          revDocs.push(doc);
        }
      });

      const instSnap = await db
        .collection('user_stocks_conso')
        .where('subStock','==','Installment')
        .get();
      let totalInstallment=0;
      instSnap.forEach(doc=>{
        const s=doc.data().stock;
        if(s!=='user_hard_pulls'&&s!=='user_loans_late_payments'){
          totalInstallment++;
        }
      });

      const totalAccounts=totalRevolving+totalInstallment;
      const rawRevPct= totalAccounts===0?0:totalRevolving/totalAccounts;
      const revPct=parseFloat(rawRevPct.toFixed(4));

      // --- 3) Utilization ---
      let totalCreditLimit=0,totalBalance=0;
      revDocs.forEach(doc=>{
        const d=doc.data();
        totalCreditLimit += d.creditLimit||0;
        totalBalance     += d.amountsOwed||0;
      });
      const rawUtil = totalCreditLimit===0?0:totalBalance/totalCreditLimit;
      const utilization = parseFloat(rawUtil.toFixed(4));

      // --- 4) Number of CFA or AF Cards with 0 Balance ---
      const afSnap = await db
        .collection('user_stocks_conso')
        .where('stock','==','user_credit_cards')
        .where('isAnnualFee','==',true)
        .get();
      const totalAF = afSnap.size;
      const cfaSnap = await db
        .collection('user_stocks_conso')
        .where('stock','==','user_credit_cards')
        .where('isCFA','==',true)
        .get();
      const totalCFA = cfaSnap.size;
      const totalCFA_AF = totalAF + totalCFA;

      const zeroBalSnap = await db
        .collection('user_stocks_conso')
        .where('stock','==','user_credit_cards')
        .where('amountsOwed','==',0)
        .get();
      let numZeroBalanceCFAorAF = 0;
      zeroBalSnap.forEach(doc=>{
        const d=doc.data();
        if(d.isAnnualFee||d.isCFA) numZeroBalanceCFAorAF++;
      });
      const valueCFA_AF = totalCFA_AF===0? null : numZeroBalanceCFAorAF;

      // --- 5) Minimum 1 loan ---
      const loansSnap = await db
        .collection('user_stocks_conso')
        .where('stock','==','user_loans')
        .get();
      const numLoans = loansSnap.size;

      // --- 6) Minimum 1 card ---
      const cardsSnap = await db
        .collection('user_stocks_conso')
        .where('stock','==','user_credit_cards')
        .get();
      const numCards = cardsSnap.size;

      // --- Prepare batch updates ---
      const batch = db.batch();

      // mapping of variation to computed value
      const mapping = {
        'Current accounts / lates': calRatio,
        'Revolving % of total': revPct,
        'Utilization': utilization,
        'Number of CFA or AF Cards with 0 Balance': valueCFA_AF,
        'Minimum 1 loan': numLoans,
        'Minimum 1 card': numCards
      };

      // update each constraint type
      for (const [variation, value] of Object.entries(mapping)) {
        const snap = await db
          .collection('user_plan_target_constraints')
          .where('AccountType_Variation','==',variation)
          .get();
        snap.forEach(doc=>{
          const old = doc.data().Current_Value;
          if (old !== value) {
            batch.set(
              db.collection('user_plan_target_constraints').doc(doc.id),
              { Current_Value: value },
              { merge: true }
            );
          }
        });
      }

      // commit all updates
      await batch.commit();

      return {
        success: true,
        numberCurrentAccounts,
        numberLates,
        calRatio,
        totalRevolving,
        totalInstallment,
        totalAccounts,
        revPct,
        utilization,
        totalAF,
        totalCFA,
        totalCFA_AF,
        numZeroBalanceCFAorAF,
        valueCFA_AF,
        numLoans,
        numCards
      };
    } catch(err) {
      console.error('Error computing current values:',err);
      throw new functions.https.HttpsError('internal',err.message||'Unknown');
    }
  }
);
