/*
1. **Scope to User**
   * Identify current user from `context.auth.uid`.
   * Query all `user_credit_cards` where `userRef == users/{uid}`.
2. **Filter Step 1 – Active Cards**
   * Keep cards where `isOpen == true` **and** `totalBalance > 0`.
   * Count results → `countAfterStep1`.
3. **Compute AZEO Flag**
   * If `countAfterStep1 == 0` → `AZEO = true`.
   * Else → `AZEO = false`.
4. **Step 3 – Exclude Ineligible Cards**
   * Remove any card where `isAnnualFee == true` **or** `isCFA == true`.
5. **Step 4 – Compute Use Age**
   * `useAgeMonths` = calendar months between `dateLastUsed` and now.
   * If `dateLastUsed` missing → set `useAgeMonths = 1`.
   * Sort remaining cards by `useAgeMs` (descending = oldest first).
   * Assign `rank = 1, 2, 3...`.
6. **Step 5 – Determine Age Risk**
   * For each card:
     * `atAgeRiskOrAZEOorBoth = true` if `AZEO == false` and `dateLastUsed` > 5 calendar months ago.
     * Else `false`.
7. **Step 6 – Upsert Results**
   * Write one doc per candidate into `/user_use_cards_list/{cardId}`.
   * Use `{ merge: true }` for idempotent updates (no duplicates).
8. **Step 7 – Cleanup Orphans**
   * Get all `/user_use_cards_list` docs for this user.
   * If a list doc’s ID is **not present** in `/user_credit_cards`, delete it.
   * (Does **not** delete or rewrite everything.)
*/

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// Do NOT call admin.initializeApp()

exports.writeUseCardsList = functions.region('us-central1').https.onCall(
  async (data, context) => {
    if (!context.auth || !context.auth.uid) return;

    const db = admin.firestore();
    const uid = context.auth.uid;
    const userRef = db.doc(`users/${uid}`);

    const now = new Date();
    const toJsDate = (ts) => {
      if (!ts) return null;
      if (typeof ts.toDate === 'function') return ts.toDate();
      if (ts._seconds != null) return new Date(ts._seconds * 1000);
      return null;
    };
    const monthDiffCalendar = (from, to) => {
      const y = to.getFullYear() - from.getFullYear();
      const m = to.getMonth() - from.getMonth();
      let diff = y * 12 + m;
      if (to.getDate() < from.getDate()) diff -= 1;
      return Math.max(0, diff);
    };
    const olderThanCalendarMonths = (d, months) => {
      if (!(d instanceof Date)) return false;
      const thresh = new Date(now);
      thresh.setMonth(thresh.getMonth() - months);
      return d.getTime() < thresh.getTime();
    };

    // Single-field query: userRef only (no composite index needed)
    const allCardsSnap = await db.collection('user_credit_cards')
      .where('userRef', '==', userRef)
      .get();

    // Step 1 filter (basis for AZEO)
    const step1 = [];
    const allIds = new Set();
    allCardsSnap.forEach(doc => {
      allIds.add(doc.id);
      const c = doc.data() || {};
      if (c.isOpen === true && Number(c.totalBalance || 0) > 0) {
        step1.push({ id: doc.id, data: c });
      }
    });

    // Step 2 count (after step 1)
    const countAfterStep1 = step1.length;

    // Step 3 exclusions
    const candidates = step1.filter(({ data }) => !(data.isCFA === true || data.isAnnualFee === true));

    // Step 5 AZEO (based on step 1 count)
    const AZEO = countAfterStep1 === 0;

    // Steps 4 & 6: compute ages/flags + rank
    const items = candidates.map(({ id, data }) => {
      const dlu = toJsDate(data.dateLastUsed);
      let useAgeMonths, useAgeDays, useAgeMs;
      if (dlu) {
        useAgeMonths = monthDiffCalendar(dlu, now);
        useAgeDays = Math.floor((now - dlu) / (24 * 60 * 60 * 1000));
        useAgeMs = now - dlu;
      } else {
        useAgeMonths = 1;   // per spec
        useAgeDays = 30;
        useAgeMs = 30 * 24 * 60 * 60 * 1000;
      }
      const atAgeRiskOrAZEOorBoth = (!AZEO && dlu ? olderThanCalendarMonths(dlu, 5) : false);
      return { id, raw: data, useAgeMonths, useAgeDays, useAgeMs, atAgeRiskOrAZEOorBoth };
    });

    items.sort((a, b) => b.useAgeMs - a.useAgeMs);
    items.forEach((it, i) => { it.rank = i + 1; });

    // Upserts
    const batch = db.batch();
    const candidateIds = new Set(items.map(it => it.id));

    for (const it of items) {
      const src = it.raw;
      const targetRef = db.collection('user_use_cards_list').doc(it.id);
      const docRefCard = db.collection('user_credit_cards').doc(it.id);

      batch.set(targetRef, {
        AZEO,
        atAgeRiskOrAZEOorBoth: it.atAgeRiskOrAZEOorBoth,
        rank: it.rank,
        useAgeMonths: it.useAgeMonths,
        useAgeDays: it.useAgeDays,

        lender: src.lender ?? null,
        commercialName: src.commercialName ?? null,
        creditLimit: src.creditLimit ?? null,
        apr: src.apr ?? null,
        totalBalance: src.totalBalance ?? null,
        dayOfMonthDue: src.dayOfMonthDue ?? null,
        minimumPayment: src.minimumPayment ?? null,
        rewardType: src.rewardType ?? null,
        isOpen: src.isOpen ?? null,
        isCFA: src.isCFA ?? null,
        isAnnualFee: src.isAnnualFee ?? null,

        dateLastUsed: src.dateLastUsed ?? null,
        dateIssued: src.dateIssued ?? null,

        userRef,
        DocRefCard: docRefCard,
        created_time: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    }

    // Cleanup: delete only orphans (list docs for this user with no origin card at all)
    const existingListSnap = await db.collection('user_use_cards_list')
      .where('userRef', '==', userRef)
      .get();

    existingListSnap.forEach(doc => {
      if (!allIds.has(doc.id)) {
        batch.delete(doc.ref);
      }
    });

    await batch.commit();

    return { ok: true, stats: { step1_count: countAfterStep1, written: items.length, AZEO, cleaned_orphans_checked: existingListSnap.size } };
  }
);
