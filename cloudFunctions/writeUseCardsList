/*
1. **Scope to user**
   * Get `uid` from `context.auth.uid`.
   * Query all cards where `userRef == users/{uid}`.

2. **Filter open cards**
   * Keep cards with `isOpen == true`.
   * (This set becomes the base universe for the list.)

3. **Count cards reporting balance**
   * From the open set, count how many have `totalBalance > 0`.
   * Save this as `cardsWithBalanceCount` (**double**) to each written doc.

4. **Exclude ineligible cards**
   * From the open set, exclude any with `isAnnualFee == true` or `isCFA == true`.
   * Remaining cards (including those with `totalBalance == 0`) become **candidates**.

5. **Compute inactivity age**
   * For each candidate, compute `useAgeMonths` as calendar months since `dateLastUsed`.
   * If `dateLastUsed` is missing, set `useAgeMonths = 1` (and `useAgeDays â‰ˆ 30`).

6. **Rank by oldest use**
   * Sort candidates by most inactive first (largest age first).
   * Assign `rank` starting at 1 (1 = oldest).

7. **Flag age-risk condition**
   * `atAgeRiskOrAZEOorBoth = true` if either:
     * `cardsWithBalanceCount == 0` **and** `dateLastUsed > 5` calendar months, **OR**
     * `dateLastUsed > 5` calendar months **and** `cardsWithBalanceCount < 2`.
   * Else `false`.

8. **Upsert results**
   * For each candidate, upsert `/user_use_cards_list/{cardId}` with:
     * `cardsWithBalanceCount` (double), `rank`, `useAgeMonths`, `useAgeDays`,
       `atAgeRiskOrAZEOorBoth`, `userRef`, `DocRefCard`, `created_time`,
       plus mirrored fields used by the UI (`lender`, `commercialName`, `apr`, `totalBalance`, `dayOfMonthDue`, `minimumPayment`, `rewardType`, `isOpen`, `isCFA`, `isAnnualFee`, `dateLastUsed`, `dateIssued`).
   * Uses `{ merge: true }` so writes are **idempotent**; doc id = source card id to avoid duplicates.

9. **Clean up orphans (selective)**
   * Load `/user_use_cards_list` for this `userRef`.
   * Delete only docs whose id no longer exists in `/user_credit_cards` for this user.
   * Does **not** blanket delete or rewrite the list.
*/

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// Do NOT call admin.initializeApp()

exports.writeUseCardsList = functions.region('us-central1').https.onCall(
  async (data, context) => {
    if (!context.auth || !context.auth.uid) return;

    const db = admin.firestore();
    const uid = context.auth.uid;
    const userRef = db.doc(`users/${uid}`);

    // Helpers
    const now = new Date();
    const toJsDate = (ts) => {
      if (!ts) return null;
      if (typeof ts.toDate === 'function') return ts.toDate();
      if (ts._seconds != null) return new Date(ts._seconds * 1000);
      return null;
    };
    const monthDiffCalendar = (from, to) => {
      const y = to.getFullYear() - from.getFullYear();
      const m = to.getMonth() - from.getMonth();
      let diff = y * 12 + m;
      if (to.getDate() < from.getDate()) diff -= 1;
      return Math.max(0, diff);
    };
    const olderThanCalendarMonths = (d, months) => {
      if (!(d instanceof Date)) return false;
      const thresh = new Date(now);
      thresh.setMonth(thresh.getMonth() - months);
      return d.getTime() < thresh.getTime();
    };

    // 1) Pull ALL cards for this user (no composite index needed)
    const allCardsSnap = await db.collection('user_credit_cards')
      .where('userRef', '==', userRef)
      .get();

    // Keep tracking sets/arrays
    const allIds = new Set();
    const openCards = [];

    allCardsSnap.forEach(doc => {
      allIds.add(doc.id);
      const c = doc.data() || {};
      if (c.isOpen === true) {
        openCards.push({ id: doc.id, data: c });
      }
    });

    // 2) Count of open cards with balance > 0  (DOUBLE field)
    const cardsWithBalanceCount = openCards.reduce((acc, { data }) => {
      const bal = Number(data.totalBalance ?? 0);
      return acc + (bal > 0 ? 1 : 0);
    }, 0);

    // 3) Build candidate list (include 0-balance cards), then exclude annual fee / CFA
    const candidates = openCards.filter(({ data }) => !(data.isCFA === true || data.isAnnualFee === true));

    // 4) Compute useAge + 5-month risk + rank
    const items = candidates.map(({ id, data }) => {
      const dlu = toJsDate(data.dateLastUsed);

      let useAgeMonths, useAgeDays, useAgeMs;
      if (dlu) {
        useAgeMonths = monthDiffCalendar(dlu, now);
        useAgeDays = Math.floor((now - dlu) / (24 * 60 * 60 * 1000));
        useAgeMs = now - dlu;
      } else {
        // Spec: missing dateLastUsed => useAge = 1 month
        useAgeMonths = 1;
        useAgeDays = 30;
        useAgeMs = 30 * 24 * 60 * 60 * 1000;
      }

      const isOlderThan5M = dlu ? olderThanCalendarMonths(dlu, 5) : (useAgeMonths > 5);
      const atAgeRiskOrAZEOorBoth =
        (isOlderThan5M && cardsWithBalanceCount === 0) ||
        (isOlderThan5M && cardsWithBalanceCount < 2);

      return {
        id,
        raw: data,
        useAgeMonths,
        useAgeDays,
        useAgeMs,
        atAgeRiskOrAZEOorBoth
      };
    });

    items.sort((a, b) => b.useAgeMs - a.useAgeMs);
    items.forEach((it, i) => { it.rank = i + 1; });

    // 5) Upserts (idempotent, same doc id as source)
    const batch = db.batch();

    for (const it of items) {
      const src = it.raw;
      const targetRef = db.collection('user_use_cards_list').doc(it.id);
      const docRefCard = db.collection('user_credit_cards').doc(it.id);

      batch.set(targetRef, {
        // New counter instead of AZEO
        cardsWithBalanceCount: Number(cardsWithBalanceCount),

        // Rank/age + condition
        rank: it.rank,
        useAgeMonths: it.useAgeMonths,
        useAgeDays: it.useAgeDays,
        atAgeRiskOrAZEOorBoth: it.atAgeRiskOrAZEOorBoth,

        // Mirrors for UI
        lender: src.lender ?? null,
        commercialName: src.commercialName ?? null,
        creditLimit: src.creditLimit ?? null,
        apr: src.apr ?? null,
        totalBalance: src.totalBalance ?? null,
        dayOfMonthDue: src.dayOfMonthDue ?? null,
        minimumPayment: src.minimumPayment ?? null,
        rewardType: src.rewardType ?? null,
        isOpen: src.isOpen ?? null,
        isCFA: src.isCFA ?? null,
        isAnnualFee: src.isAnnualFee ?? null,

        // Dates (preserve if present)
        dateLastUsed: src.dateLastUsed ?? null,
        dateIssued: src.dateIssued ?? null,

        // Refs
        userRef,
        DocRefCard: docRefCard,

        // Bookkeeping
        created_time: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    }

    // 6) Cleanup: delete only orphans for this user
    const existingListSnap = await db.collection('user_use_cards_list')
      .where('userRef', '==', userRef)
      .get();

    existingListSnap.forEach(doc => {
      if (!allIds.has(doc.id)) {
        batch.delete(doc.ref);
      }
    });

    await batch.commit();

    return {
      ok: true,
      stats: {
        open_count: openCards.length,
        cards_with_balance_count: cardsWithBalanceCount,
        written: items.length
      },
    };
  }
);
