const functions = require('firebase-functions');
const admin = require('firebase-admin');
// Do NOT call admin.initializeApp() in your FF environment.
const db = admin.firestore();
db.settings({ ignoreUndefinedProperties: true });

exports.writeOpenActionsList = functions.region('us-central1').https.onCall(
  async (data, context) => {
    if (!context.auth || !context.auth.uid) return;
    const uid = context.auth.uid;
    const userRef = db.collection('users').doc(uid);

    // ---------- helpers ----------
    const nz = (v, d=0) => (typeof v === 'number' && !isNaN(v) ? v : d);
    const asBool = (v, d=false) => (typeof v === 'boolean' ? v : d);
    const isTs = (t) => t && typeof t.toDate === 'function';
    const toTs = (d) => admin.firestore.Timestamp.fromDate(d);
    const trunc = (n) => Math.max(0, Math.floor(n));
    const ceil = Math.ceil;
    const min = Math.min;

    const nowInTZ = (tz="America/New_York") => {
      const fmt = new Intl.DateTimeFormat('en-US', {
        timeZone: tz,
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit',
        hour12: false
      });
      const parts = Object.fromEntries(fmt.formatToParts(new Date()).map(p => [p.type, p.value]));
      // parts: {year:'2025', month:'11', day:'04', hour:'13', minute:'05', second:'22'}
      return new Date(`${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${parts.minute}:${parts.second}`);
    };
    const addMonthsFractional = (date, months) => {
      const d = new Date(date.getTime());
      const whole = Math.trunc(months);
      const frac = months - whole;
      // add whole calendar months
      if (whole !== 0) {
        const m = d.getMonth() + whole;
        d.setMonth(m);
      }
      // add fractional part as days (average month length)
      if (frac !== 0) {
        const days = frac * 30.4375; // acceptable per spec
        d.setDate(d.getDate() + days);
      }
      return d;
    };
    const daysAgo = (d1, d0) => (d1 - d0) / (1000 * 60 * 60 * 24);

    const asDate = (maybeTsOrDate) => {
      if (!maybeTsOrDate) return null;
      if (isTs(maybeTsOrDate)) return maybeTsOrDate.toDate();
      if (maybeTsOrDate instanceof Date) return maybeTsOrDate;
      const t = new Date(maybeTsOrDate);
      return isNaN(+t) ? null : t;
    };

    // ---------- load knobs ----------
    // Users/{uid}
    const userDoc = await userRef.get();
    const user = userDoc.exists ? userDoc.data() : {};
    const wantsToAllowLoans = asBool(user.wantsToAllowLoans, false);
    const imposeMaxLoanNumber = asBool(user.imposeMaxLoanNumber, false);

    // Adjustments (values + time caps/intervals)
    const adjustSnap = await db.collection('user_openAndCloseAdjustments')
      .where('userRef', '==', userRef).get();
    const getAdjVal = (uniqueName) => {
      let v = null;
      adjustSnap.forEach(doc => {
        const d = doc.data();
        if ((d.uniqueName || d.Name) === uniqueName) {
          v = nz(d.User_Value ?? d.Value ?? d.value, null);
        }
      });
      return v;
    };
    const timeRows = [];
    adjustSnap.forEach(doc => {
      const d = doc.data();
      if ((d.Type || d.type) === 'Time') timeRows.push(d);
    });
    // Expected Time fields (names can be adapted to your exact schema labels)
    const pickTime = (label) => {
      const row = timeRows.find(r => (r.uniqueName || r.Name) === label);
      return row ? nz(row.User_Value ?? row.Value, 0) : 0;
    };
    const yearlyOpensMax = pickTime('Yearly opens allowable');
    const halfYearRequestsMax = pickTime('Half-yearly requests allowable');
    const minMonthsBetweenOpens = pickTime('Min interval between opens in LTM');
    const minMonthsBetweenRequests = pickTime('Min interval between requests in LTM');

    const pctRevolvingMin = nz(getAdjVal('Revolving % of total'), 0); // e.g., 70
    const currentPerLateMultiplier = nz(getAdjVal('Current accounts / lates'), 0);
    const maxLoansAllowed = nz(getAdjVal('Max loans allowed'), null);

    // Credit High Achiever targets
    const chaSnap = await db.collection('credit_high_achiever_account_numbers')
      .where('userRef', '==', userRef).get();
    let chaSum = 0;
    chaSnap.forEach(doc => {
      const v = nz(doc.data().Value ?? doc.data().value, 0);
      chaSum += v;
    });

    // Conso
    const consoSnap = await db.collection('user_stocks_conso')
      .where('userRef', '==', userRef).get();

    // Requests (hard pulls)
    const pullsSnap = await db.collection('user_hard_pulls')
      .where('userRef', '==', userRef).get();

    // ---------- parse conso ----------
    const isCard = (d) => (d.stock || d.stockType) === 'user_credit_cards';
    const isLoan = (d) => (d.stock || d.stockType) === 'user_loans';
    const isAccountRow = (d) => isCard(d) || isLoan(d);
    const isLateRow = (d) => (d.stock || d.stockType || d.category) === 'late' || d.isLate === true || (d.kind === 'late');
    const isCollectionRow = (d) => (d.stock || d.stockType || d.category) === 'collection' || d.isCollection === true || (d.kind === 'collection');

    const nowNY = nowInTZ('America/New_York');
    const day365 = new Date(nowNY.getTime()); day365.setDate(day365.getDate() - 365);
    const day180 = new Date(nowNY.getTime()); day180.setDate(day180.getDate() - 180);

    let openCards = 0, openLoans = 0;
    let countLates = 0, countCollections = 0;
    let opensIn365 = 0;
    let mostRecentOpenDate = null;
    let mostRecentOpenType = null; // 'card' | 'loan'

    consoSnap.forEach(doc => {
      const d = doc.data();

      // Current open accounts = isOpen && isCurrent
      if (isAccountRow(d)) {
        const open = (d.isOpen === true) && (d.isCurrent === true);
        if (open) {
          if (isCard(d)) openCards++;
          else if (isLoan(d)) openLoans++;
        }
      }

      // Lates / Collections
      if (isLateRow(d)) countLates++;
      if (isCollectionRow(d)) countCollections++;

      // Opens in last 365d + most recent open
      if (isAccountRow(d)) {
        const dt = asDate(d.DOFRecord ?? d.dateOpened ?? d.date_issued ?? d.Date_issued);
        if (dt) {
          if (dt >= day365) opensIn365++;
          if (!mostRecentOpenDate || dt > mostRecentOpenDate) {
            mostRecentOpenDate = dt;
            mostRecentOpenType = isCard(d) ? 'card' : (isLoan(d) ? 'loan' : null);
          } else if (mostRecentOpenDate && dt.getTime() === mostRecentOpenDate.getTime()) {
            // tie-breaker at same ms: default to card if ambiguous
            const thisType = isCard(d) ? 'card' : (isLoan(d) ? 'loan' : null);
            if (thisType === 'card' && mostRecentOpenType !== 'card') {
              mostRecentOpenType = 'card';
            }
          }
        }
      }
    });

    // Requests in last 180d + most recent request
    let requestsIn180 = 0;
    let mostRecentReqDate = null;
    pullsSnap.forEach(doc => {
      const d = doc.data();
      const dt = asDate(d.DOFRecord ?? d.datePulled ?? d.dateRequested);
      if (dt) {
        if (dt >= day180) requestsIn180++;
        if (!mostRecentReqDate || dt > mostRecentReqDate) mostRecentReqDate = dt;
      }
    });

    // ---------- Step 1: Goal ----------
    const totalLatesAndCollections = countLates + countCollections; // no dedupe
    const pathA = currentPerLateMultiplier * totalLatesAndCollections;
    const pathB = chaSum;
    const goalTotal = Math.max(nz(pathA,0), nz(pathB,0));

    // ---------- Step 2: Current ----------
    const currentOpenTotal = openCards + openLoans;

    // ---------- Step 3: Needed ----------
    const neededTotal = Math.max(0, goalTotal - currentOpenTotal);

    // ---------- Step 4: Allocation ----------
    let cardsToOpen = 0;
    let loansToOpen = 0;

    if (!wantsToAllowLoans) {
      cardsToOpen = neededTotal;
      loansToOpen = 0;
    } else if (imposeMaxLoanNumber) {
      const loanCap = maxLoansAllowed == null ? 0 : Math.max(0, maxLoansAllowed - openLoans);
      const minCards = ceil((nz(pctRevolvingMin,0) / 100) * neededTotal);
      cardsToOpen = Math.min(neededTotal, minCards);
      loansToOpen = Math.min(Math.max(neededTotal - cardsToOpen, 0), loanCap);
      // guarantee total by pushing remainder to cards
      const shortfall = neededTotal - (cardsToOpen + loansToOpen);
      if (shortfall > 0) cardsToOpen += shortfall;
    } else {
      const minCards = ceil((nz(pctRevolvingMin,0) / 100) * neededTotal);
      cardsToOpen = Math.min(neededTotal, minCards);
      loansToOpen = Math.max(0, neededTotal - cardsToOpen);
    }

    const allocHeadroom = cardsToOpen + loansToOpen;

    // ---------- Step 5: Timing (caps + intervals) ----------
    const yearlyHeadroom = Math.max(0, nz(yearlyOpensMax,0) - nz(opensIn365,0));
    const halfYearHeadroom = Math.max(0, nz(halfYearRequestsMax,0) - nz(requestsIn180,0));

    // intervals satisfied?
    const openIntMonths = nz(minMonthsBetweenOpens, 0);
    const reqIntMonths = nz(minMonthsBetweenRequests, 0);

    const lastOpenDate = mostRecentOpenDate;
    const lastReqDate = mostRecentReqDate;

    const nextByOpenInterval = lastOpenDate ? addMonthsFractional(lastOpenDate, openIntMonths) : new Date(0);
    const nextByReqInterval  = lastReqDate  ? addMonthsFractional(lastReqDate,  reqIntMonths)  : new Date(0);
    const intervalsSatisfied = (nowNY >= nextByOpenInterval) && (nowNY >= nextByReqInterval);

    const capsBlocked = (yearlyHeadroom <= 0) || (halfYearHeadroom <= 0);
    const intervalsBlocked = !intervalsSatisfied;

    let blockReason = null;
    if (capsBlocked) {
      if (yearlyHeadroom <= 0) blockReason = 'yearly_cap_reached';
      if (halfYearHeadroom <= 0) blockReason = blockReason ? `${blockReason}|halfyear_requests_cap_reached` : 'halfyear_requests_cap_reached';
    }
    if (intervalsBlocked) {
      blockReason = blockReason ? `${blockReason}|interval_not_satisfied` : 'interval_not_satisfied';
    }

    let slotsNow = 0;
    if (!capsBlocked && !intervalsBlocked && allocHeadroom > 0) {
      if (openIntMonths === 0 && reqIntMonths === 0) {
        // multiple immediate opens allowed
        slotsNow = min(allocHeadroom, yearlyHeadroom, halfYearHeadroom);
      } else {
        // throttle to one "now"
        slotsNow = min(1, allocHeadroom, yearlyHeadroom, halfYearHeadroom);
      }
    }

    // When can they open next if blocked now?
    let nextEligibleDate = null;
    if (slotsNow === 0) {
      const capWindows = [];
      // Next by intervals
      capWindows.push(nextByOpenInterval);
      capWindows.push(nextByReqInterval);
      // Next by caps: when will 365/180 windows free a slot? (approx: add 1 day to window start)
      // Weâ€™ll compute conservative dates based on oldest included items.
      // For simplicity: if headroom==0, set to now + 1 day (UI signal; precise date can be computed in a follow-up CF).
      if (yearlyHeadroom <= 0) {
        const d = new Date(nowNY.getTime()); d.setDate(d.getDate() + 1);
        capWindows.push(d);
      }
      if (halfYearHeadroom <= 0) {
        const d = new Date(nowNY.getTime()); d.setDate(d.getDate() + 1);
        capWindows.push(d);
      }
      nextEligibleDate = capWindows.length ? new Date(Math.max(...capWindows.map(d => d.getTime()))) : null;
    }

    // ---------- Step 6: Build sequence for "now" ----------
    const sequence = [];
    let remCards = cardsToOpen;
    let remLoans = loansToOpen;

    const pickNextType = (prevType) => {
      // Start by alternation preference
      let preferred = null;
      if (!prevType) {
        // first pick alternates from MOST RECENT:
        preferred = (mostRecentOpenType === 'card') ? 'loan' : 'card';
      } else {
        preferred = (prevType === 'card') ? 'loan' : 'card';
      }

      const prefOk = (preferred === 'card' && remCards > 0) || (preferred === 'loan' && remLoans > 0);
      if (prefOk) return preferred;

      // fallbacks
      if (remCards > 0) return 'card';
      if (remLoans > 0 && wantsToAllowLoans) return 'loan';
      return null;
    };

    if (slotsNow > 0) {
      let prev = null;
      for (let i = 0; i < slotsNow; i++) {
        const t = pickNextType(prev);
        if (!t) break;
        sequence.push(t);
        if (t === 'card') remCards--;
        else if (t === 'loan') remLoans--;
        prev = t;
      }
      // if sequence shorter than slotsNow because a bucket ran dry, keep filling with cards to guarantee total
      while (sequence.length < slotsNow && remCards > 0) {
        sequence.push('card');
        remCards--;
      }
      // final guard: truncate to slotsNow
      if (sequence.length > slotsNow) sequence.length = slotsNow;
    }

    // ---------- Write output doc ----------
    const out = {
      userRef,
      created_time: admin.firestore.Timestamp.now(),
      status: (slotsNow > 0) ? 'proposed' : 'blocked',
      proposed: {
        can_open_now: slotsNow > 0,
        count_now: slotsNow,
        sequence_now: sequence, // e.g., ["card","loan"]
        next_eligible_date: nextEligibleDate ? toTs(nextEligibleDate) : null,
        cadence_months: {
          opens_min_interval: openIntMonths,
          requests_min_interval: reqIntMonths
        }
      },
      allocation: {
        goal_total: nz(goalTotal,0),
        current_open_cards: nz(openCards,0),
        current_open_loans: nz(openLoans,0),
        needed_total: nz(neededTotal,0),
        revPctMinCards: nz(pctRevolvingMin,0),
        loan_cap: (imposeMaxLoanNumber ? nz(maxLoansAllowed,0) : null),
        cards_to_open: nz(cardsToOpen,0),
        loans_to_open: nz(loansToOpen,0)
      },
      timing: {
        opens_in_365: nz(opensIn365,0),
        requests_in_180: nz(requestsIn180,0),
        most_recent_open: mostRecentOpenDate ? toTs(mostRecentOpenDate) : null,
        most_recent_request: mostRecentReqDate ? toTs(mostRecentReqDate) : null,
        yearly_opens_max: nz(yearlyOpensMax,0),
        halfyear_requests_max: nz(halfYearRequestsMax,0),
        min_months_between_opens: nz(minMonthsBetweenOpens,0),
        min_months_between_requests: nz(minMonthsBetweenRequests,0),
        is_blocked_caps: !!capsBlocked,
        is_blocked_intervals: !!intervalsBlocked,
        block_reason: blockReason
      },
      selection_protocol: 'alternate_by_most_recent_type',
      notes: 'Write specific products separately after user picks from /user_card_recommendations.'
    };

    const docRef = await db.collection('user_open_actions_list').add(out);
    return { id: docRef.id, proposed: out.proposed, allocation: out.allocation, timing: out.timing };
  }
);

