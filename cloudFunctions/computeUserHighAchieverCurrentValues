// This function correctly calculates
// Unique_Name = Number of Loans
// Unique_Name = Number of Credit Cards
// Unique_Name = Number of Annual Fee Cards
// Unique_Name = Number of CFA Cards
// Unique_Name = Revolving % of Total Accounts
// Unique_Name = Number of Requests in LTM
// Unique_Name = Credit Limit on Loans
// Unique_Name = Credit Limit on Credit Cards
// Unique_Name = Balance on Loans
// Unique_Name = Balance on Credit Cards
// Unique_Name = Amounts owed on lates
// Unique_Name = Amounts owed on charge offs
// Unique_Name = Amounts owed on 3rd party collections

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.computeUserHighAchieverCurrentValues = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    if (!context.auth || !context.auth.uid) {
      throw new functions.https.HttpsError('unauthenticated','Must be signed in.');
    }
    const uid = context.auth.uid;
    const db = admin.firestore();
    const userRef = db.doc(`users/${uid}`);

    // 1) Load all user_high_achiever_targets docs
    const targetsSnap = await db
      .collection('user_high_achiever_targets')
      .get();
    if (targetsSnap.empty) {
      throw new functions.https.HttpsError('not-found','No docs found in user_high_achiever_targets');
    }

    // 2) Prepare batch for updates
    const batch = db.batch();

    // Precompute cutoff for LTM (12 months ago)
    const twelveMonthsAgo = new Date();
    twelveMonthsAgo.setFullYear(twelveMonthsAgo.getFullYear() - 1);
    const cutoffMs = twelveMonthsAgo.getTime();

    // 3) Loop through each doc and compute Current_Value
    for (const doc of targetsSnap.docs) {
      const data       = doc.data();
      const docRef     = db.collection('user_high_achiever_targets').doc(doc.id);
      const oldValue   = data.Current_Value;
      let   currentValue = oldValue;

      switch (data.Unique_Name) {
        case 'Number of Loans': {
          const snap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_loans')
            .where('userRef', '==', userRef)
            .get();
          currentValue = snap.size;
          break;
        }

        case 'Number of Credit Cards': {
          const snap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_credit_cards')
            .where('userRef', '==', userRef)
            .get();
          currentValue = snap.size;
          break;
        }

        case 'Number of Annual Fee Cards': {
          const snap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_credit_cards')
            .where('userRef', '==', userRef)
            .where('isAnnualFee', '==', true)
            .get();
          currentValue = snap.size;
          break;
        }

        case 'Number of CFA Cards': {
          const snap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_credit_cards')
            .where('userRef', '==', userRef)
            .where('isCFA', '==', true)
            .get();
          currentValue = snap.size;
          break;
        }

        case 'Revolving % of Total Accounts': {
          const revSnap = await db
            .collection('user_stocks_conso')
            .where('subStock', '==', 'Revolving')
            .where('userRef', '==', userRef)
            .get();
          const totalRevolving = revSnap.docs.filter(d => {
            const s = d.data().stock;
            return s !== 'user_hard_pulls' && s !== 'user_credit_cards_late_payments';
          }).length;

          const instSnap = await db
            .collection('user_stocks_conso')
            .where('subStock', '==', 'Installment')
            .where('userRef', '==', userRef)
            .get();
          const totalInstallment = instSnap.docs.filter(d => {
            const s = d.data().stock;
            return s !== 'user_hard_pulls' && s !== 'user_loans_late_payments';
          }).length;

          const totalAccounts = totalRevolving + totalInstallment;
          currentValue = totalAccounts > 0 ? totalRevolving / totalAccounts : 0;
          break;
        }

        case 'Number of Requests in LTM': {
          const allPulls = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_hard_pulls')
            .where('userRef', '==', userRef)
            .get();
          const recentPulls = allPulls.docs.filter(d => 
            d.data().DOFRecord.toMillis() >= cutoffMs
          );
          currentValue = recentPulls.length;
          break;
        }

        case 'Credit Limit on Loans': {
          const snap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_loans')
            .where('userRef', '==', userRef)
            .get();
          currentValue = snap.docs.reduce((sum, d) => sum + (d.data().creditLimit || 0), 0);
          break;
        }

        case 'Credit Limit on Credit Cards': {
          const snap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_credit_cards')
            .where('userRef', '==', userRef)
            .get();
          currentValue = snap.docs.reduce((sum, d) => sum + (d.data().creditLimit || 0), 0);
          break;
        }

        case 'Balance on Loans': {
          const snap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_loans')
            .where('userRef', '==', userRef)
            .get();
          currentValue = snap.docs.reduce((sum, d) => sum + (d.data().amountsOwed || 0), 0);
          break;
        }

        case 'Balance on Credit Cards': {
          const snap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_credit_cards')
            .where('userRef', '==', userRef)
            .get();
          currentValue = snap.docs.reduce((sum, d) => sum + (d.data().amountsOwed || 0), 0);
          break;
        }

        case 'Amounts owed on lates': {
          const latesSnap = await db
            .collection('user_stocks_conso')
            .where('stock', 'in', [
              'user_credit_cards_late_payments',
              'user_loans_late_payments'
            ])
            .where('userRef', '==', userRef)
            .get();

          currentValue = latesSnap.docs.reduce((sum, d) => sum + (d.data().amountsOwed || 0), 0);
          break;
        }

        case 'Amounts owed on charge offs': {
          const latesSnap = await db
            .collection('user_stocks_conso')
            .where('stock', 'in', [
              'user_credit_cards_late_payments',
              'user_loans_late_payments'
            ])
            .where('userRef', '==', userRef)
            .get();

          let sumChargedOff = 0;
          for (const lateDoc of latesSnap.docs) {
            const stockColl = lateDoc.data().stock;
            const srcSnap = await db
              .collection(stockColl)
              .doc(lateDoc.id)
              .get();
            const src = srcSnap.data() || {};
            if (src.chargedOff && !src.sentToCollections) {
              sumChargedOff += lateDoc.data().amountsOwed || 0;
            }
          }
          currentValue = sumChargedOff;
          break;
        }

        case 'Amounts owed on account collections': {
          const latesSnap = await db
            .collection('user_stocks_conso')
            .where('stock', 'in', [
              'user_credit_cards_late_payments',
              'user_loans_late_payments'
            ])
            .where('userRef', '==', userRef)
            .get();

          let amountsOwedCollections = 0;
          for (const lateDoc of latesSnap.docs) {
            const stockColl = lateDoc.data().stock;
            const srcSnap = await db
              .collection(stockColl)
              .doc(lateDoc.id)
              .get();
            const src = srcSnap.data() || {};
            if (src.sentToCollections) {
              amountsOwedCollections += lateDoc.data().amountsOwed || 0;
            }
          }
          currentValue = amountsOwedCollections;
          break;
        }

        default:
          continue;
      }

      // 4) Only update if changed
      if (currentValue !== oldValue) {
        batch.set(docRef, { Current_Value: currentValue }, { merge: true });
      }
    }

    // 5) Commit all updates
    await batch.commit();
    return { success: true, updated: targetsSnap.size };
  });
