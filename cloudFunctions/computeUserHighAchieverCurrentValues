// This function correctly calculates
// Unique_Name = Number of Loans
// Unique_Name = Number of Credit Cards
// Unique_Name = Number of Annual Fee Cards
// Unique_Name = Number of CFA Cards
// Unique_Name = Revolving % of Total Accounts
// Unique_Name = Number of Requests in LTM
// Unique_Name = Credit Limit on Loans
// Unique_Name = Credit Limit on Credit Cards
// Unique_Name = Balance on Loans
// Unique_Name = Balance on Credit Cards
// Unique_Name = Amounts owed on lates

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.computeUserHighAchieverCurrentValues = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    if (!context.auth || !context.auth.uid) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Must be signed in.'
      );
    }
    const uid = context.auth.uid;
    const db = admin.firestore();

    // 1) Load all user_high_achiever_targets docs
    const targetsSnap = await db
      .collection('user_high_achiever_targets')
      .get();
    if (targetsSnap.empty) {
      throw new functions.https.HttpsError(
        'not-found',
        'No docs found in user_high_achiever_targets'
      );
    }

    // 2) Prepare batch for updates
    const batch = db.batch();

    // Precompute cutoff for LTM (12 months ago)
    const twelveMonthsAgo = new Date();
    twelveMonthsAgo.setFullYear(twelveMonthsAgo.getFullYear() - 1);
    const cutoffMs = twelveMonthsAgo.getTime();

    // 3) Loop through each doc and compute Current_Value
    for (const doc of targetsSnap.docs) {
      const data       = doc.data();
      const docRef     = db.collection('user_high_achiever_targets').doc(doc.id);
      const oldValue   = data.Current_Value;
      let   currentValue = oldValue;

      switch (data.Unique_Name) {
        case 'Number of Loans': {
          const loansSnap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_loans')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .get();
          currentValue = loansSnap.size;
          break;
        }

        case 'Number of Credit Cards': {
          const cardsSnap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_credit_cards')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .get();
          currentValue = cardsSnap.size;
          break;
        }

        case 'Number of Annual Fee Cards': {
          const afSnap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_credit_cards')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .where('isAnnualFee', '==', true)
            .get();
          currentValue = afSnap.size;
          break;
        }

        case 'Number of CFA Cards': {
          const cfaSnap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_credit_cards')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .where('isCFA', '==', true)
            .get();
          currentValue = cfaSnap.size;
          break;
        }

        case 'Revolving % of Total Accounts': {
          const revSnap = await db
            .collection('user_stocks_conso')
            .where('subStock', '==', 'Revolving')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .get();
          const totalRevolving = revSnap.docs.filter(d => {
            const s = d.data().stock;
            return s !== 'user_hard_pulls' && s !== 'user_credit_cards_late_payments';
          }).length;

          const instSnap = await db
            .collection('user_stocks_conso')
            .where('subStock', '==', 'Installment')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .get();
          const totalInstallment = instSnap.docs.filter(d => {
            const s = d.data().stock;
            return s !== 'user_hard_pulls' && s !== 'user_loans_late_payments';
          }).length;

          const totalAccounts = totalRevolving + totalInstallment;
          currentValue = totalAccounts > 0 
            ? totalRevolving / totalAccounts 
            : 0;
          break;
        }

        case 'Number of Requests in LTM': {
          const allPullsSnap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_hard_pulls')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .get();
          const recentPulls = allPullsSnap.docs.filter(d => 
            d.data().DOFRecord.toMillis() >= cutoffMs
          );
          currentValue = recentPulls.length;
          break;
        }

        case 'Credit Limit on Loans': {
          const loansSnap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_loans')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .get();
          let sumCreditLimit = 0;
          loansSnap.docs.forEach(d => {
            const val = d.data().creditLimit;
            sumCreditLimit += (typeof val === 'number' ? val : 0);
          });
          currentValue = sumCreditLimit;
          break;
        }

        case 'Credit Limit on Credit Cards': {
          const cardsSnap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_credit_cards')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .get();
          let sumCreditLimitCC = 0;
          cardsSnap.docs.forEach(d => {
            const val = d.data().creditLimit;
            sumCreditLimitCC += (typeof val === 'number' ? val : 0);
          });
          currentValue = sumCreditLimitCC;
          break;
        }

        case 'Balance on Loans': {
          const loansSnap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_loans')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .get();
          let sumAmountsOwed = 0;
          loansSnap.docs.forEach(d => {
            const val = d.data().amountsOwed;
            sumAmountsOwed += (typeof val === 'number' ? val : 0);
          });
          currentValue = sumAmountsOwed;
          break;
        }

        case 'Balance on Credit Cards': {
          const cardsSnap = await db
            .collection('user_stocks_conso')
            .where('stock', '==', 'user_credit_cards')
            .where('userRef', '==', db.doc(`users/${uid}`))
            .get();
          let sumAmountsOwedCC = 0;
          cardsSnap.docs.forEach(d => {
            const val = d.data().amountsOwed;
            sumAmountsOwedCC += (typeof val === 'number' ? val : 0);
          });
          currentValue = sumAmountsOwedCC;
          break;
        }

        case 'Amounts owed on lates': {
          // fetch all late-payment entries
          const latesSnap = await db
            .collection('user_stocks_conso')
            .where('stock', 'in', [
              'user_credit_cards_late_payments',
              'user_loans_late_payments'
            ])
            .where('userRef', '==', db.doc(`users/${uid}`))
            .get();

          let amountsOwedLates = 0;
          for (const lateDoc of latesSnap.docs) {
            const stockColl = lateDoc.data().stock;
            // load source from root-level collection
            const sourceSnap = await db
              .collection(stockColl)
              .doc(lateDoc.id)
              .get();
            if (!sourceSnap.exists) continue;
            const src = sourceSnap.data();
            if (!src.chargedOff && !src.sentToCollections) {
              amountsOwedLates += Number(lateDoc.data().amountsOwed) || 0;
            }
          }
          currentValue = amountsOwedLates;
          break;
        }

        default:
          continue; // skip unhandled Unique_Name
      }

      // 4) Only queue update if the value changed
      if (currentValue !== oldValue) {
        batch.set(docRef, { Current_Value: currentValue }, { merge: true });
      }
    }

    // 5) Commit all batched updates
    await batch.commit();
    return { success: true, updated: targetsSnap.size };
  });
