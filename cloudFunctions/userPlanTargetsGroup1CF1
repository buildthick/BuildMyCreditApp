// Update: name changed to userPlanTargetsGroup1CF1
// This version does not write anything but does compute:
// unrestricted values
// days and months in plan
// blockers for open/close actions

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.userPlanTargetsGroup1CF1 = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    if (!context.auth || !context.auth.uid) {
      throw new functions.https.HttpsError('unauthenticated','Must be signed in.');
    }
    const uid = context.auth.uid;
    const db = admin.firestore();
    const userRef = db.doc(`users/${uid}`);

    // 1) Fetch user's target_date and compute time-left vars
    const userSnap = await userRef.get();
    const targetTs = userSnap.data()?.target_date;
    if (!targetTs) {
      throw new functions.https.HttpsError('failed-precondition','No target_date set');
    }
    const planEnd = targetTs.toDate();
    const nowNY = new Date().toLocaleString('en-US', { timeZone: 'America/New_York' });
    const nowDate = new Date(nowNY);
    const msLeft = planEnd.getTime() - nowDate.getTime();
    const daysLeftInPlan = Math.floor(msLeft / (1000 * 60 * 60 * 24));
    const monthsLeftInPlan = daysLeftInPlan / 30;

    // 2) Load all plan docs for Group 1
    const planSnap = await db
      .collection('user_plan_targets')
      .where('userRef','==', userRef)
      .where('CloudFunctionGroup','==', 1)
      .get();
    if (planSnap.empty) {
      return { success: true, processed: 0 };
    }

    // 3) Load blocker constraints of interest
    const blockerVars = [
      'Number of CFA or AF Cards with 0 Balance',
      'Latest allowable close',
      'Latest allowable open'
    ];
    const constrSnap = await db
      .collection('user_plan_target_constraints')
      .where('userRef','==',userRef)
      .where('CloudFunctionGroup','==',1)
      .where('AccountType_Variation','in', blockerVars)
      .get();
    const byVar = {};
    constrSnap.docs.forEach(d => {
      const c = d.data();
      byVar[c.AccountType_Variation] = c;
    });

    // 4) Evaluate closeAllowed & closeReason
    const cfaZero     = byVar['Number of CFA or AF Cards with 0 Balance'];
    const latestClose = byVar['Latest allowable close'];

    const failCFA = cfaZero && (() => {
      const isMin = String(cfaZero.Max_or_Min).toLowerCase() === 'min';
      return isMin
        ? cfaZero.Current_Value < cfaZero.Target_Value
        : cfaZero.Current_Value > cfaZero.Target_Value;
    })();

    const failTime = latestClose && (() => {
      const isMin = String(latestClose.Max_or_Min).toLowerCase() === 'min';
      return isMin
        ? latestClose.Current_Value < latestClose.Target_Value
        : latestClose.Current_Value > latestClose.Target_Value;
    })();

    const closeAllowed = !(failCFA || failTime);
    let closeReason;
    if (closeAllowed) {
      closeReason = 'Nothing blocks close actions';
    } else if (failCFA && failTime) {
      closeReason = "There are no CFA or annual fee cards to close — and even if there were, you're too close to the target date to safely close an account.";
    } else if (failCFA) {
      closeReason = "Close actions aren't possible because there is no CFA or annual fee card without a balance";
    } else {
      closeReason = "Too little time before your target date to close accounts — either change the date, or modify the cutoff (2 months by default)";
    }

    // 5) Evaluate openAllowed & openReason
    const latestOpen = byVar['Latest allowable open'];
    const failOpen = latestOpen && (() => {
      const isMin = String(latestOpen.Max_or_Min).toLowerCase() === 'min';
      return isMin
        ? latestOpen.Current_Value < latestOpen.Target_Value
        : latestOpen.Current_Value > latestOpen.Target_Value;
    })();

    const openAllowed = !failOpen;
    const openReason = openAllowed
      ? 'Nothing blocks open actions'
      : "You are too close to your target date to open accounts — either change the date, or modify the cutoff";

    // 6) Batch-write only the four fields + timestamp
    const batch = db.batch();
    planSnap.docs.forEach(doc => {
      const ref = db.collection('user_plan_targets').doc(doc.id);
      batch.set(ref, {
        Close_Allowed: closeAllowed,
        Close_Allowed_Reason: closeReason,
        Open_Allowed: openAllowed,
        Open_Allowed_Reason: openReason,
        lastUpdated: admin.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
    });
    await batch.commit();

    return { success: true, processed: planSnap.size };
  });
