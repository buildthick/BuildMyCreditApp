const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.transferOpenCloseMod = functions.region('us-central1').https.onCall(
  async (data, context) => {
    if (!context.auth || !context.auth.uid) {
      return; // or: throw new functions.https.HttpsError('unauthenticated', 'Sign-in required');
    }

    try {
      const uid = context.auth.uid;
      const db = admin.firestore();

      const srcSnap = await db.collection('openAndCloseAdjustments').get();
      if (srcSnap.empty) {
        return { written: 0, skipped: 0 };
      }

      let batch = db.batch();
      let opCount = 0;
      let skipped = 0;
      const now = admin.firestore.FieldValue.serverTimestamp();

      for (const doc of srcSnap.docs) {
        const src = doc.data() || {};

        // Build the target payload (excluding timestamps for equality check)
        const targetBase = {};
        if (src.Action_Type !== undefined) targetBase.Action_Type = src.Action_Type;
        if (src.Sub_Action_Type !== undefined) targetBase.Sub_Action_Type = src.Sub_Action_Type;
        if (src.Type !== undefined) targetBase.Type = src.Type;
        if (src.Unique_Name !== undefined) targetBase.Unique_Name = src.Unique_Name;
        if (src.modType !== undefined) targetBase.modType = src.modType;
        if (src.Default_Interval !== undefined) targetBase.Default_Interval = src.Default_Interval;
        if (src.Default_Interval_Unit !== undefined) targetBase.Default_Interval_Unit = src.Default_Interval_Unit;
        if (src.Default_Value !== undefined) targetBase.Default_Value = src.Default_Value;

        if (src.Default_Value !== undefined) targetBase.User_Value = src.Default_Value;
        if (src.Default_Interval !== undefined) targetBase.User_Interval = src.Default_Interval;
        if (src.Default_Interval_Unit !== undefined) targetBase.User_Interval_Unit = src.Default_Interval_Unit;

        targetBase.userRef = db.doc(`users/${uid}`);
        targetBase.srcId = doc.id; // optional audit field you kept

        const destId = `${uid}_${doc.id}`;
        const destRef = db.collection('user_openAndCloseAdjustments').doc(destId);

        // ==== Skip-if-unchanged check ====
        const existingSnap = await destRef.get();
        if (existingSnap.exists) {
          const existing = existingSnap.data() || {};

          // Compare only keys present in targetBase (ignore timestamps)
          let equal = true;
          for (const [k, v] of Object.entries(targetBase)) {
            const cur = existing[k];

            // Handle DocumentReference equality by path
            if (k === 'userRef') {
              const curPath = cur && typeof cur.path === 'string' ? cur.path : null;
              const tgtPath = targetBase.userRef.path;
              if (curPath !== tgtPath) { equal = false; break; }
              continue;
            }

            // Primitive / JSON-safe shallow compare
            // (null vs undefined are different; we purposely omitted undefineds above)
            if (typeof v === 'object' && v !== null) {
              // Shallow object compare via JSON (safe here since values are scalars)
              if (JSON.stringify(cur) !== JSON.stringify(v)) { equal = false; break; }
            } else {
              if (cur !== v) { equal = false; break; }
            }
          }

          if (equal) {
            skipped++;
            continue; // nothing changed; do not write
          }
        }
        // ==================================

        // Add timestamps only when we actually write
        const target = { ...targetBase, updated_time: now };
        if (data && data.addCreatedTime === true && !existingSnap.exists) {
          target.created_time = now;
        }

        batch.set(destRef, target, { merge: true });
        opCount++;

        if (opCount % 450 === 0) {
          await batch.commit();
          batch = db.batch();
        }
      }

      if (opCount % 450 !== 0) {
        await batch.commit();
      }

      return { written: opCount, skipped };
    } catch (err) {
      // Optional: convert to HttpsError for surfaced UI errors
      // throw new functions.https.HttpsError('internal', err.message);
      return { error: true, message: err?.message || String(err) };
    }
  }
);
