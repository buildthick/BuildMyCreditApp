const functions = require('firebase-functions');
const admin = require('firebase-admin');
// admin.initializeApp()

exports.consolidateUserStocks = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    // 1) Auth check
    const uid = context.auth && context.auth.uid;
    if (!uid) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Must be called while authenticated.'
      );
    }

    const db = admin.firestore();
    const userDocRef = db.doc(`users/${uid}`);

    // 2) Query by the actual DocumentReference
    const pullsSnap = await db
      .collection('user_hard_pulls')
      .where('userRef', '==', userDocRef)
      .get();

    if (pullsSnap.empty) {
      return { success: true, written: 0, message: 'No hard pulls to consolidate.' };
    }

    // 3) Map & write
    const written = await mapRequests(pullsSnap, db);
    return { success: true, written };
  });

async function mapRequests(snap, db) {
  const batch = db.batch();
  let writeCount = 0;

  for (const doc of snap.docs) {
    const d = doc.data();
    const consoRef = db.collection('user_stocks_conso').doc(doc.id);

    // Flat map of fields at the top level
    const flatData = {
      DOFRecord: d.dateOfRequest,    // Firestore Timestamp
      userRef:   d.userRef,          // Firestore DocumentReference
      stockType: doc.ref.path,
      subStock:  d.debtType,
      lender:    d.lender,
      name:      d.productName
    };

    // Idempotency check
    const existing = await consoRef.get();
    if (
      existing.exists &&
      JSON.stringify(existing.data()) === JSON.stringify(flatData)
    ) {
      continue;
    }

    batch.set(consoRef, flatData, { merge: true });
    writeCount++;
  }

  if (writeCount > 0) {
    await batch.commit();
  }
  return writeCount;
}
