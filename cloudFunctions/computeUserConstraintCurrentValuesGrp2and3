// This version correctly writes the Current_Value field for:
// AccountType_Variation = Requests allowable
// AccountType_Variation = Min interval between requests in LTM

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.computeUserConstraintCurrentValuesGrp2and3 = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    // 1) Auth check
    const uid = context.auth && context.auth.uid;
    if (!uid) {
      throw new functions.https.HttpsError('unauthenticated', 'Must be signed in.');
    }
    const db = admin.firestore();

    // Helper: extract NYC local Y/M/D from a Date
    function getNYCDateParts(date) {
      const fmt = new Intl.DateTimeFormat('en-US', {
        timeZone: 'America/New_York',
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
      });
      const parts = fmt.formatToParts(date);
      let y, m, d;
      parts.forEach(p => {
        if (p.type === 'year')  y = +p.value;
        if (p.type === 'month') m = +p.value;
        if (p.type === 'day')   d = +p.value;
      });
      return { y, m, d };
    }

    // Compute months between record and now (NYC-normalized)
    function monthsBetween(recordDate, nowNorm) {
      const recParts = getNYCDateParts(recordDate);
      const recNorm  = new Date(recParts.y, recParts.m - 1, recParts.d);
      let yDiff = nowNorm.getFullYear() - recNorm.getFullYear();
      let mDiff = nowNorm.getMonth()    - recNorm.getMonth();
      let months = yDiff * 12 + mDiff;
      let dDiff = nowNorm.getDate() - recNorm.getDate();
      if (dDiff < 0) {
        months--;
        const daysInPrev = new Date(
          recNorm.getFullYear(),
          recNorm.getMonth(),
          0
        ).getDate();
        dDiff += daysInPrev;
      }
      const daysInMonth = new Date(
        recNorm.getFullYear(),
        recNorm.getMonth() + 1,
        0
      ).getDate();
      return months + dDiff / daysInMonth;
    }

    try {
      // normalize "today" to NYC local date
      const now = new Date();
      const nowParts = getNYCDateParts(now);
      const nowNorm  = new Date(nowParts.y, nowParts.m - 1, nowParts.d);

      const batch = db.batch();

      // --- 1) Requests allowable (hard pulls in last 12 months) ---
      const pullsSnap = await db
        .collection('user_stocks_conso')
        .where('stock', '==', 'user_hard_pulls')
        .get();

      let requestsAllowableCount = 0;
      pullsSnap.forEach(doc => {
        const recDate = doc.data().DOFRecord.toDate();
        if (monthsBetween(recDate, nowNorm) < 12) {
          requestsAllowableCount++;
        }
      });

      const reqSnap = await db
        .collection('user_plan_target_constraints')
        .where('AccountType_Variation', '==', 'Requests allowable')
        .get();
      reqSnap.forEach(doc => {
        if (doc.data().Current_Value !== requestsAllowableCount) {
          batch.set(
            db.collection('user_plan_target_constraints').doc(doc.id),
            { Current_Value: requestsAllowableCount },
            { merge: true }
          );
        }
      });

      // --- 2) Min interval between requests in LTM (hard pulls) ---
      // build a 12-month cutoff
      const cutoff = new Date(nowNorm);
      cutoff.setMonth(cutoff.getMonth() - 12);
      const cutoffNorm = new Date(
        cutoff.getFullYear(),
        cutoff.getMonth(),
        cutoff.getDate()
      );

      // fetch all hard-pull DOFRecords
      const pullsAllSnap = await db
        .collection('user_stocks_conso')
        .where('stock', '==', 'user_hard_pulls')
        .get();

      const dates = pullsAllSnap.docs
        .map(doc => {
          const d = doc.data().DOFRecord.toDate();
          const { y, m, d: day } = getNYCDateParts(d);
          return new Date(y, m - 1, day);
        })
        .filter(d => d > cutoffNorm)
        .sort((a, b) => a - b);

      let minDiffDays = Infinity;
      for (let i = 1; i < dates.length; i++) {
        const diff = (dates[i] - dates[i - 1]) / (1000 * 60 * 60 * 24);
        if (diff < minDiffDays) minDiffDays = diff;
      }
      const minIntervalRequests = dates.length < 2
        ? null
        : parseFloat((minDiffDays / 30).toFixed(2));

      const minReqSnap = await db
        .collection('user_plan_target_constraints')
        .where('AccountType_Variation', '==', 'Min interval between requests in LTM')
        .get();
      minReqSnap.forEach(doc => {
        if (doc.data().Current_Value !== minIntervalRequests) {
          batch.set(
            db.collection('user_plan_target_constraints').doc(doc.id),
            { Current_Value: minIntervalRequests },
            { merge: true }
          );
        }
      });

      // commit writes
      await batch.commit();

      return {
        success: true,
        requestsAllowableCount,
        minIntervalRequests
      };
    } catch (err) {
      console.error('Error computing Requests and Min-interval:', err);
      throw new functions.https.HttpsError('internal', err.message || 'Unknown error');
    }
  });
