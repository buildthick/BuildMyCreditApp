const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.userPlanTargetsGroup1 = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    if (!context.auth || !context.auth.uid) {
      throw new functions.https.HttpsError('unauthenticated','Must be signed in.');
    }
    const uid = context.auth.uid;
    const db = admin.firestore();
    const userRef = db.doc(`users/${uid}`);

    // 1) Fetch user's target_date and compute time-left vars
    const userSnap = await userRef.get();
    const targetTs = userSnap.data()?.target_date;
    if (!targetTs) {
      throw new functions.https.HttpsError('failed-precondition','No target_date set');
    }
    const planEnd = targetTs.toDate();
    const nowNY = new Date().toLocaleString('en-US', { timeZone: 'America/New_York' });
    const nowDate = new Date(nowNY);
    const msLeft = planEnd.getTime() - nowDate.getTime();
    const daysLeftInPlan = Math.floor(msLeft / (1000 * 60 * 60 * 24));
    const monthsLeftInPlan = daysLeftInPlan / 30;

    // 2) Load all plan docs for Group 1
    const planSnap = await db
      .collection('user_plan_targets')
      .where('userRef','==', userRef)
      .where('CloudFunctionGroup','==', 1)
      .get();
    if (planSnap.empty) {
      return { success: true, processed: 0 };
    }

    // 3) Load master specs for Group 1 into a map
    const masterSnap = await db
      .collection('credit_high_achievers_targets')
      .where('CloudFunctionGroup','==', 1)
      .get();
    const masterByName = {};
    masterSnap.docs.forEach(d => {
      const m = d.data();
      masterByName[m.Unique_Name] = m;
    });

    // 4) Build planByName for quick access to Current_Value
    const planByName = {};
    planSnap.docs.forEach(d => {
      const p = d.data();
      planByName[p.Unique_Name] = p;
    });

    // 5) Compute unrestricted opens/closes
    const getMaster = name => masterByName[name]?.Target_Value || 0;
    const getCurrent = name => planByName[name]?.Current_Value || 0;

    const unrestrictedOpensInstallment  = getMaster('Number of Loans') - getCurrent('Number of Loans');
    const unrestrictedClosesInstallment = getMaster('Number of CFA Loans') - getCurrent('Number of CFA Loans');
    const unrestrictedOpensRevolving    = getMaster('Number of Credit Cards') - getCurrent('Number of Credit Cards');
    const closesAnnualFee               = getMaster('Number of Annual Fee Cards') - getCurrent('Number of Annual Fee Cards');
    const closesCFAcards                = getMaster('Number of CFA Cards') - getCurrent('Number of CFA Cards');
    const unrestrictedClosesRevolving   = closesAnnualFee + closesCFAcards;

    // 6) Fetch blocker constraints (Close)
    const blockerCloseSnap = await db
      .collection('user_plan_target_constraints')
      .where('userRef','==', userRef)
      .where('CloudFunctionGroup','==', 1)
      .where('Is_Blocker','==', true)
      .where('Action_OR_ActionsPair','==', 'Close')
      .orderBy('Rank_In_Group')
      .get();

    // 7) Fetch blocker constraints (Open)
    const blockerOpenSnap = await db
      .collection('user_plan_target_constraints')
      .where('userRef','==', userRef)
      .where('CloudFunctionGroup','==', 1)
      .where('Is_Blocker','==', true)
      .where('Action_OR_ActionsPair','==', 'Open')
      .orderBy('Rank_In_Group')
      .get();

    // 8) Evaluate blockers in-memory
    const closeBlockerResults = {};
    planSnap.docs.forEach(d => {
      const name = d.data().Unique_Name;
      let override = null;
      blockerCloseSnap.docs.forEach(bcDoc => {
        const c = bcDoc.data();
        if (c.Unique_Name !== name) return;
        const current = getCurrent(name);
        const constraint = c.Value;
        if (c.Max_or_Min === 'min' && current < constraint) {
          override = constraint;
        }
        if (c.Max_or_Min === 'max' && current > constraint) {
          override = constraint;
        }
        if (override !== null) return; // first blocker in rank order
      });
      closeBlockerResults[name] = override;
    });

    const openBlockerResults = {};
    planSnap.docs.forEach(d => {
      const name = d.data().Unique_Name;
      let override = null;
      blockerOpenSnap.docs.forEach(boDoc => {
        const c = boDoc.data();
        if (c.Unique_Name !== name) return;
        const current = getCurrent(name);
        const constraint = c.Value;
        if (c.Max_or_Min === 'min' && current < constraint) {
          override = constraint;
        }
        if (c.Max_or_Min === 'max' && current > constraint) {
          override = constraint;
        }
        if (override !== null) return;
      });
      openBlockerResults[name] = override;
    });

    // 9) Return all computed variables for inspection
    return {
      success: true,
      processed: planSnap.size,
      daysLeftInPlan,
      monthsLeftInPlan,
      unrestrictedOpensInstallment,
      unrestrictedClosesInstallment,
      unrestrictedOpensRevolving,
      unrestrictedClosesRevolving,
      closeBlockerResults,
      openBlockerResults
    };
  }
);
