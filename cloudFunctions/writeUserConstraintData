const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.writeUserConstraintData = functions.region('us-central1').https.onCall(
  async (data, context) => {
    // 1) Auth check
    const uid = context.auth && context.auth.uid;
    if (!uid) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Must be signed in.'
      );
    }

    const db = admin.firestore();
    const userRef = db.collection('Users').doc(uid);

    try {
      // 2) Load static templates
      const staticSnap = await db
        .collection('plan_target_constraints')
        .get();

      // 3) Load existing user-specific copies
      const userSnap = await db
        .collection('user_plan_target_constraints')
        .get();
      const existing = {};
      userSnap.forEach(doc => {
        existing[doc.id] = doc.data();
      });

      // 4) Batch writes only when userRef is missing or different
      const batch = db.batch();
      let written = 0;

      staticSnap.forEach(doc => {
        const id = doc.id;
        const src = doc.data();
        const old = existing[id];
        const needsWrite = !old || old.userRef?.id !== uid;

        if (needsWrite) {
          const destRef = db
            .collection('user_plan_target_constraints')
            .doc(id);

          batch.set(
            destRef,
            {
              ...src,
              userRef: userRef
            },
            { merge: true }
          );
          written++;
        }
      });

      // 5) Commit batch if there are writes
      if (written > 0) {
        await batch.commit();
      }

      return { success: true, attempted: staticSnap.size, written };
    } catch (err) {
      console.error('Error copying constraints:', err);
      throw new functions.https.HttpsError(
        'internal',
        err.message || 'Unknown error'
      );
    }
  }
);
