const functions = require('firebase-functions');
const admin     = require('firebase-admin');
// FlutterFlow initializes admin

exports.writeAndComputePayPrioritiesList = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    if (!context.auth?.uid) {
      throw new functions.https.HttpsError('unauthenticated', 'Must be signed in.');
    }

    const db = admin.firestore();
    const uid = context.auth.uid;
    const userRef = db.doc(`users/${uid}`);

    const now = Date.now();
    const MS_PER_DAY = 24 * 60 * 60 * 1000;

    const asNum = (v, d=0) => Number.isFinite(Number(v)) ? Number(v) : d;
    const toTierFromDOFD = (dofdTs) => {
      if (!dofdTs) return 30;
      const t = dofdTs?.toDate ? dofdTs.toDate().getTime() : (dofdTs instanceof Date ? dofdTs.getTime() : 0);
      if (!t) return 30;
      const days = Math.max(0, Math.floor((now - t) / MS_PER_DAY));
      const raw  = Math.ceil(days / 30) * 30;
      return Math.min(180, Math.max(30, raw)); // 30..180
    };

    const monthlyBudget = asNum((await userRef.get()).get('monthly_budget'), 0);
    let budgetLeft = monthlyBudget;

    // Discover current accounts from conso (exclude hard pulls)
    const consoSnap = await db.collection('user_stocks_conso')
      .where('userRef','==', userRef).get();

    const conso = consoSnap.docs
      .map(d => ({ id: d.id, ...d.data() }))
      .filter(d => d.stock !== 'user_hard_pulls');

    const cardIds = conso.filter(x => x.stock === 'user_credit_cards').map(x => x.id);
    const loanIds = conso.filter(x => x.stock === 'user_loans').map(x => x.id);

    // Origin docs
    const [cardDocs, loanDocs] = await Promise.all([
      Promise.all(cardIds.map(id => db.collection('user_credit_cards').doc(id).get())),
      Promise.all(loanIds.map(id => db.collection('user_loans').doc(id).get()))
    ]);
    const cardsMap = {};
    cardDocs.forEach(s => { if (s.exists) cardsMap[s.id] = { id: s.id, ref: s.ref, ...s.data() }; });
    const loansMap = {};
    loanDocs.forEach(s => { if (s.exists) loansMap[s.id] = { id: s.id, ref: s.ref, ...s.data() }; });

    // Late payments (origin, unpaid only)
    const [lateCardsSnap, lateLoansSnap] = await Promise.all([
      db.collection('user_credit_cards_late_payments').where('userRef','==', userRef).where('isPaid','==', false).get(),
      db.collection('user_loans_late_payments').where('userRef','==', userRef).where('isPaid','==', false).get()
    ]);
    const lateItems = [
      ...lateCardsSnap.docs.map(d => ({ id: d.id, ref: d.ref, kind: 'cardLate', ...d.data() })),
      ...lateLoansSnap.docs.map(d => ({ id: d.id, ref: d.ref, kind: 'loanLate', ...d.data() }))
    ];

    // 3rd-party collections (unpaid)
    const tpcSnap = await db.collection('user_collections_3rd_party')
      .where('userRef','==', userRef).where('isPaid','==', false).get();
    const tpcItems = tpcSnap.docs.map(d => ({ id: d.id, ref: d.ref, ...d.data() }));

    // Build working rows
    const items = [];

    // Accounts
    conso.forEach(src => {
      if (src.stock !== 'user_credit_cards' && src.stock !== 'user_loans') return;

      const isCard = src.stock === 'user_credit_cards';
      const o = isCard ? cardsMap[src.id] : loansMap[src.id];
      if (!o) return;

      const apr        = asNum(o.apr, 0);
      const minPayment = isCard ? asNum(o.minimumPayment, 0) : asNum(o.monthlyPayment, 0);
      const balance    = isCard ? asNum(o.totalBalance, 0) : asNum(o.balance, 0);
      const dueDay     = asNum(o.dayOfMonthDue ?? null, null);

      items.push({
        kind: 'account',
        id: src.id,
        stock: src.stock,
        name: o.commercialName ?? src.name ?? null,
        lender: o.lender ?? src.lender ?? null,
        sourceRef: o.ref,
        apr,
        minPayment,
        balance,
        dueDay,
        alloc_total: 0,
        alloc_min: 0,
        alloc_card_extra: 0,
      });
    });

    // Unpaid lates (some may be sentToCollections)
    lateItems.forEach(L => {
      const severity = String(toTierFromDOFD(L.DOFD));
      const sentToCollections = !!L.sentToCollections;
      const amount = asNum(L.amount, 0);

      items.push({
        kind: sentToCollections ? 'collection_from_account' : 'late',
        id: L.id,
        stock: L.kind === 'cardLate' ? 'user_credit_cards_late_payments' : 'user_loans_late_payments',
        name: L.name ?? null,
        lender: L.lender ?? null,
        sourceRef: L.ref,
        severity,
        amount,
        alloc_total: 0,
        alloc_late: 0,
        alloc_collections: 0,
      });
    });

    // Third-party collections
    tpcItems.forEach(C => {
      items.push({
        kind: 'collection_third_party',
        id: C.id,
        stock: 'user_collections_3rd_party',
        name: C.originalProvider ?? C.collectionsAgency ?? C.type ?? null,
        lender: C.collectionsAgency ?? null,
        sourceRef: C.ref,
        amount: asNum(C.amount, 0),
        alloc_total: 0,
        alloc_collections: 0,
      });
    });

    // ---- Allocation ----
    const accounts = items.filter(i => i.kind === 'account');
    const totalMin = accounts.reduce((s,i) => s + i.minPayment, 0);

    if (budgetLeft > 0) {
      if (budgetLeft >= totalMin) {
        accounts
          .sort((a,b) => (b.apr - a.apr) || ((a.dueDay ?? 32) - (b.dueDay ?? 32)))
          .forEach(i => {
            const pay = i.minPayment;
            const alloc = Math.min(budgetLeft, pay);
            i.alloc_min += alloc;
            i.alloc_total += alloc;
            budgetLeft -= alloc;
          });
      } else {
        const weights = accounts.map(i => ({
          id: i.id,
          w: Math.max(0, i.minPayment * (i.apr / 100)),
          dueDay: i.dueDay
        }));
        const sumW = weights.reduce((s,x)=>s+x.w,0);
        weights.sort((a,b) => (b.w - a.w) || ((a.dueDay ?? 32) - (b.dueDay ?? 32)));
        let remaining = budgetLeft;
        for (const w of weights) {
          const it = accounts.find(z => z.id === w.id);
          if (!it) continue;
          const target = sumW > 0 ? (w.w / sumW) * budgetLeft : 0;
          const pay = Math.min(remaining, Math.max(0, target));
          it.alloc_min += pay;
          it.alloc_total += pay;
          remaining -= pay;
        }
        budgetLeft = Math.max(0, remaining);
        for (const w of weights) {
          if (budgetLeft <= 0) break;
          const it = accounts.find(z => z.id === w.id);
          const delta = Math.min(budgetLeft, Math.max(0, it.minPayment - it.alloc_min));
          if (delta > 0) {
            it.alloc_min += delta;
            it.alloc_total += delta;
            budgetLeft -= delta;
          }
        }
      }
    }

    // Lates by severity
    items
      .filter(i => i.kind === 'late')
      .sort((a,b) => (parseInt(b.severity)||0) - (parseInt(a.severity)||0))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const need = i.amount - i.alloc_total;
        if (need <= 0) return;
        const pay = Math.min(budgetLeft, need);
        i.alloc_late += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    // Card extra principal
    accounts
      .filter(a => a.stock === 'user_credit_cards')
      .sort((a,b) => (b.apr - a.apr) || ((a.dueDay ?? 32) - (b.dueDay ?? 32)))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const remaining = Math.max(0, i.balance - i.alloc_total);
        if (remaining <= 0) return;
        const pay = Math.min(budgetLeft, remaining);
        i.alloc_card_extra += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    // Collections
    items
      .filter(i => i.kind === 'collection_from_account')
      .sort((a,b) => (b.amount||0) - (a.amount||0))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const need = i.amount - i.alloc_total;
        if (need <= 0) return;
        const pay = Math.min(budgetLeft, need);
        i.alloc_collections += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    items
      .filter(i => i.kind === 'collection_third_party')
      .sort((a,b) => (b.amount||0) - (a.amount||0))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const need = i.amount - i.alloc_total;
        if (need <= 0) return;
        const pay = Math.min(budgetLeft, need);
        i.alloc_collections += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    // ---- Persist (delta-aware; write only new/changed) ----
    const priorityKey = (i) => (
      i.kind === 'account' && i.alloc_min > 0 ? 1 :
      i.kind === 'late'    && i.alloc_total > 0 ? 2 :
      i.kind === 'account' && i.alloc_card_extra > 0 ? 3 :
      (i.kind === 'collection_from_account' || i.kind === 'collection_third_party') && i.alloc_total > 0 ? 4 : 5
    );

    const ranked = [...items].sort((a,b) => {
      const pa = priorityKey(a), pb = priorityKey(b);
      if (pa !== pb) return pa - pb;
      return (b.alloc_total||0) - (a.alloc_total||0);
    });

    const existingSnap = await db.collection('user_pay_priority_list')
      .where('userRef', '==', userRef).get();

    const existingMap = {};
    existingSnap.forEach(d => existingMap[d.id] = d.data());

    const currentIds = new Set(items.map(i => i.id));
    const batch = db.batch();

    existingSnap.forEach(d => { if (!currentIds.has(d.id)) batch.delete(d.ref); });

    ranked.forEach((i, idx) => {
      const docRef = db.collection('user_pay_priority_list').doc(i.id);
      const base = {
        userRef,
        rank: idx + 1,
        monthlyBudget,
        availableRemainder: Number(budgetLeft.toFixed(2)),
        DocRef: i.sourceRef || null,
      };

      let newData;

      if (i.kind === 'account') {
        const breakdown =
          i.stock === 'user_credit_cards'
            ? {
                minPayment: Number(i.alloc_min.toFixed(2)),
                cardExtra: Number(i.alloc_card_extra.toFixed(2)),
              }
            : {
                minPayment: Number(i.alloc_min.toFixed(2)),
              };

        newData = {
          ...base,
          stockType: i.stock,
          name: i.name,
          lender: i.lender,
          apr: i.apr,
          balance: Number(i.balance.toFixed(2)),
          minPayment: Number(i.minPayment.toFixed(2)),
          dayOfMonthDue: i.dueDay ?? null,
          budgetAllocated: Number(i.alloc_total.toFixed(2)),
          allocationBreakdown: breakdown,
        };
      } else if (i.kind === 'late') {
        newData = {
          ...base,
          stockType: i.stock,
          name: i.name,
          lender: i.lender,
          severity: i.severity,
          amount: Number(i.amount.toFixed(2)),
          budgetAllocated: Number(i.alloc_total.toFixed(2)),
          allocationBreakdown: {
            lateSeverityPayment: Number(i.alloc_late.toFixed(2)),
          },
        };
      } else {
        newData = {
          ...base,
          stockType: i.stock,
          name: i.name,
          lender: i.lender,
          amount: Number(i.amount.toFixed(2)),
          budgetAllocated: Number(i.alloc_total.toFixed(2)),
          allocationBreakdown: {
            collections: Number(i.alloc_collections.toFixed(2)),
          },
        };
      }

      const prev = existingMap[i.id];
      if (!prev || JSON.stringify(prev) !== JSON.stringify(newData)) {
        batch.set(docRef, newData, { merge: true });
      }
    });

    await batch.commit();
    return { success: true, count: items.length, availableRemainder: Number(budgetLeft.toFixed(2)) };
  });
