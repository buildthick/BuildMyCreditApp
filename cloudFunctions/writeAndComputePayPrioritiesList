/*
Payment allocation waterfall

Minimum payments:
Allocate the minimum payment on all credit cards and the monthly payment on all loans.
Order: highest APR first, then earlier dayOfMonthDue (tiebreak).
If monthlyBudget < sum of all minimums, allocate proportionally by (APR × minPayment),
then sweep any rounding remainder in the same order.
→ Recorded as allocationBreakdown.minPayment

Unpaid lates:
Allocate to unpaid late payments.
Order: by severity — 180 → 120 → 90 → 60 → 30.
→ Recorded as allocationBreakdown.lateSeverityPayment

Extra principal on credit cards:
Allocate remaining budget to the gap between current balance and already allocated payments on cards.
Order: (1) Annual-fee cards by APR (tiebreak earlier due day),
       (2) CFA cards by APR (tiebreak earlier due day),
       (3) all other cards by APR (tiebreak earlier due day).
→ Recorded as allocationBreakdown.cardExtra

Collections:
Allocate next to collections originating from accounts (sentToCollections == true), highest amount first;
then to third-party collections (user_collections_3rd_party), highest amount first.
→ Recorded as allocationBreakdown.collections

This structure allocates the entire monthlyBudget unless all balances are fully covered,
in which case any remainder is left unallocated and all PAY actions are complete in the current month.
*/



const functions = require('firebase-functions');
const admin     = require('firebase-admin');
// FlutterFlow initializes admin

exports.writeAndComputePayPrioritiesList = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    if (!context.auth?.uid) {
      throw new functions.https.HttpsError('unauthenticated', 'Must be signed in.');
    }

    const db = admin.firestore();
    const uid = context.auth.uid;
    const userRef = db.doc(`users/${uid}`);

    const now = Date.now();
    const MS_PER_DAY = 24 * 60 * 60 * 1000;

    const asNum = (v, d=0) => Number.isFinite(Number(v)) ? Number(v) : d;
    const toTierFromDOFD = (dofdTs) => {
      if (!dofdTs) return 30;
      const t = dofdTs?.toDate ? dofdTs.toDate().getTime() : (dofdTs instanceof Date ? dofdTs.getTime() : 0);
      if (!t) return 30;
      const days = Math.max(0, Math.floor((now - t) / MS_PER_DAY));
      const raw  = Math.ceil(days / 30) * 30;
      return Math.min(180, Math.max(30, raw)); // 30..180
    };

    const monthlyBudget = asNum((await userRef.get()).get('monthly_budget'), 0);
    let budgetLeft = monthlyBudget;

    // Discover current accounts from conso (exclude hard pulls)
    const consoSnap = await db.collection('user_stocks_conso')
      .where('userRef','==', userRef).get();

    const conso = consoSnap.docs
      .map(d => ({ id: d.id, ...d.data() }))
      .filter(d => d.stock !== 'user_hard_pulls');

    const cardIds = conso.filter(x => x.stock === 'user_credit_cards').map(x => x.id);
    const loanIds = conso.filter(x => x.stock === 'user_loans').map(x => x.id);

    // Origin docs
    const [cardDocs, loanDocs] = await Promise.all([
      Promise.all(cardIds.map(id => db.collection('user_credit_cards').doc(id).get())),
      Promise.all(loanIds.map(id => db.collection('user_loans').doc(id).get()))
    ]);
    const cardsMap = {};
    cardDocs.forEach(s => { if (s.exists) cardsMap[s.id] = { id: s.id, ref: s.ref, ...s.data() }; });
    const loansMap = {};
    loanDocs.forEach(s => { if (s.exists) loansMap[s.id] = { id: s.id, ref: s.ref, ...s.data() }; });

    // Late payments (origin, unpaid only)
    const [lateCardsSnap, lateLoansSnap] = await Promise.all([
      db.collection('user_credit_cards_late_payments').where('userRef','==', userRef).where('isPaid','==', false).get(),
      db.collection('user_loans_late_payments').where('userRef','==', userRef).where('isPaid','==', false).get()
    ]);
    const lateItems = [
      ...lateCardsSnap.docs.map(d => ({ id: d.id, ref: d.ref, kind: 'cardLate', ...d.data() })),
      ...lateLoansSnap.docs.map(d => ({ id: d.id, ref: d.ref, kind: 'loanLate', ...d.data() }))
    ];

    // 3rd-party collections (unpaid)
    const tpcSnap = await db.collection('user_collections_3rd_party')
      .where('userRef','==', userRef).where('isPaid','==', false).get();
    const tpcItems = tpcSnap.docs.map(d => ({ id: d.id, ref: d.ref, ...d.data() }));

    // Build working rows
    const items = [];

    // Accounts
    conso.forEach(src => {
      if (src.stock !== 'user_credit_cards' && src.stock !== 'user_loans') return;

      const isCard = src.stock === 'user_credit_cards';
      const o = isCard ? cardsMap[src.id] : loansMap[src.id];
      if (!o) return;

      const apr        = asNum(o.apr, 0);
      const minPayment = isCard ? asNum(o.minimumPayment, 0) : asNum(o.monthlyPayment, 0);
      const balance    = isCard ? asNum(o.totalBalance, 0) : asNum(o.balance, 0);
      const dueDay     = asNum(o.dayOfMonthDue ?? null, null);

      items.push({
        kind: 'account',
        id: src.id,
        stock: src.stock,
        name: o.commercialName ?? src.name ?? null,
        lender: o.lender ?? src.lender ?? null,
        sourceRef: o.ref,
        apr,
        minPayment,
        balance,
        dueDay,
        alloc_total: 0,
        alloc_min: 0,
        alloc_card_extra: 0,
      });
    });

    // Unpaid lates (some may be sentToCollections)
    lateItems.forEach(L => {
      const severity = String(toTierFromDOFD(L.DOFD));
      const sentToCollections = !!L.sentToCollections;
      const amount = asNum(L.amount, 0);

      items.push({
        kind: sentToCollections ? 'collection_from_account' : 'late',
        id: L.id,
        stock: L.kind === 'cardLate' ? 'user_credit_cards_late_payments' : 'user_loans_late_payments',
        name: L.name ?? null,
        lender: L.lender ?? null,
        sourceRef: L.ref,
        severity,
        amount,
        alloc_total: 0,
        alloc_late: 0,
        alloc_collections: 0,
      });
    });

    // Third-party collections
    tpcItems.forEach(C => {
      items.push({
        kind: 'collection_third_party',
        id: C.id,
        stock: 'user_collections_3rd_party',
        name: C.originalProvider ?? C.collectionsAgency ?? C.type ?? null,
        lender: C.collectionsAgency ?? null,
        sourceRef: C.ref,
        amount: asNum(C.amount, 0),
        alloc_total: 0,
        alloc_collections: 0,
      });
    });

    // ---- Allocation ----
    const accounts = items.filter(i => i.kind === 'account');
    const totalMin = accounts.reduce((s,i) => s + i.minPayment, 0);

    if (budgetLeft > 0) {
      if (budgetLeft >= totalMin) {
        accounts
          .sort((a,b) => (b.apr - a.apr) || ((a.dueDay ?? 32) - (b.dueDay ?? 32)))
          .forEach(i => {
            const pay = i.minPayment;
            const alloc = Math.min(budgetLeft, pay);
            i.alloc_min += alloc;
            i.alloc_total += alloc;
            budgetLeft -= alloc;
          });
      } else {
        const weights = accounts.map(i => ({
          id: i.id,
          w: Math.max(0, i.minPayment * (i.apr / 100)),
          dueDay: i.dueDay
        }));
        const sumW = weights.reduce((s,x)=>s+x.w,0);
        weights.sort((a,b) => (b.w - a.w) || ((a.dueDay ?? 32) - (b.dueDay ?? 32)));
        let remaining = budgetLeft;
        for (const w of weights) {
          const it = accounts.find(z => z.id === w.id);
          if (!it) continue;
          const target = sumW > 0 ? (w.w / sumW) * budgetLeft : 0;
          const pay = Math.min(remaining, Math.max(0, target));
          it.alloc_min += pay;
          it.alloc_total += pay;
          remaining -= pay;
        }
        budgetLeft = Math.max(0, remaining);
        for (const w of weights) {
          if (budgetLeft <= 0) break;
          const it = accounts.find(z => z.id === w.id);
          const delta = Math.min(budgetLeft, Math.max(0, it.minPayment - it.alloc_min));
          if (delta > 0) {
            it.alloc_min += delta;
            it.alloc_total += delta;
            budgetLeft -= delta;
          }
        }
      }
    }

    // Lates by severity
    items
      .filter(i => i.kind === 'late')
      .sort((a,b) => (parseInt(b.severity)||0) - (parseInt(a.severity)||0))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const need = i.amount - i.alloc_total;
        if (need <= 0) return;
        const pay = Math.min(budgetLeft, need);
        i.alloc_late += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    // Card extra principal
    accounts
      .filter(a => a.stock === 'user_credit_cards')
      .sort((a,b) => (b.apr - a.apr) || ((a.dueDay ?? 32) - (b.dueDay ?? 32)))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const remaining = Math.max(0, i.balance - i.alloc_total);
        if (remaining <= 0) return;
        const pay = Math.min(budgetLeft, remaining);
        i.alloc_card_extra += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    // Collections
    items
      .filter(i => i.kind === 'collection_from_account')
      .sort((a,b) => (b.amount||0) - (a.amount||0))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const need = i.amount - i.alloc_total;
        if (need <= 0) return;
        const pay = Math.min(budgetLeft, need);
        i.alloc_collections += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    items
      .filter(i => i.kind === 'collection_third_party')
      .sort((a,b) => (b.amount||0) - (a.amount||0))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const need = i.amount - i.alloc_total;
        if (need <= 0) return;
        const pay = Math.min(budgetLeft, need);
        i.alloc_collections += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    // ---- Persist (delta-aware; write only new/changed) ----
    const priorityKey = (i) => (
      i.kind === 'account' && i.alloc_min > 0 ? 1 :
      i.kind === 'late'    && i.alloc_total > 0 ? 2 :
      i.kind === 'account' && i.alloc_card_extra > 0 ? 3 :
      (i.kind === 'collection_from_account' || i.kind === 'collection_third_party') && i.alloc_total > 0 ? 4 : 5
    );

    const ranked = [...items].sort((a,b) => {
      const pa = priorityKey(a), pb = priorityKey(b);
      if (pa !== pb) return pa - pb;
      return (b.alloc_total||0) - (a.alloc_total||0);
    });

    const existingSnap = await db.collection('user_pay_priority_list')
      .where('userRef', '==', userRef).get();

    const existingMap = {};
    existingSnap.forEach(d => existingMap[d.id] = d.data());

    const currentIds = new Set(items.map(i => i.id));
    const batch = db.batch();

    existingSnap.forEach(d => { if (!currentIds.has(d.id)) batch.delete(d.ref); });

    ranked.forEach((i, idx) => {
      const docRef = db.collection('user_pay_priority_list').doc(i.id);
      const base = {
        userRef,
        rank: idx + 1,
        monthlyBudget,
        availableRemainder: Number(budgetLeft.toFixed(2)),
        DocRef: i.sourceRef || null,
      };

      let newData;

      if (i.kind === 'account') {
        const breakdown =
          i.stock === 'user_credit_cards'
            ? {
                minPayment: Number(i.alloc_min.toFixed(2)),
                cardExtra: Number(i.alloc_card_extra.toFixed(2)),
              }
            : {
                minPayment: Number(i.alloc_min.toFixed(2)),
              };

        newData = {
          ...base,
          stockType: i.stock,
          name: i.name,
          lender: i.lender,
          apr: i.apr,
          balance: Number(i.balance.toFixed(2)),
          minPayment: Number(i.minPayment.toFixed(2)),
          dayOfMonthDue: i.dueDay ?? null,
          budgetAllocated: Number(i.alloc_total.toFixed(2)),
          allocationBreakdown: breakdown,
        };
      } else if (i.kind === 'late') {
        newData = {
          ...base,
          stockType: i.stock,
          name: i.name,
          lender: i.lender,
          severity: i.severity,
          amount: Number(i.amount.toFixed(2)),
          budgetAllocated: Number(i.alloc_total.toFixed(2)),
          allocationBreakdown: {
            lateSeverityPayment: Number(i.alloc_late.toFixed(2)),
          },
        };
      } else {
        newData = {
          ...base,
          stockType: i.stock,
          name: i.name,
          lender: i.lender,
          amount: Number(i.amount.toFixed(2)),
          budgetAllocated: Number(i.alloc_total.toFixed(2)),
          allocationBreakdown: {
            collections: Number(i.alloc_collections.toFixed(2)),
          },
        };
      }

      const prev = existingMap[i.id];
      if (!prev || JSON.stringify(prev) !== JSON.stringify(newData)) {
        batch.set(docRef, newData, { merge: true });
      }
    });

    await batch.commit();
    return { success: true, count: items.length, availableRemainder: Number(budgetLeft.toFixed(2)) };
  });
