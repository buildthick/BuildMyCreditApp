/*
Payment allocation waterfall

Minimum payments:
Allocate the minimum payment on all credit cards and the monthly payment on all loans.
Order: highest APR first, then earlier dayOfMonthDue (tiebreak).
If monthlyBudget < sum of all minimums, allocate proportionally by (APR × minPayment),
then sweep any rounding remainder in the same order.
→ Recorded as allocationBreakdown.minPayment

Unpaid lates:
Allocate to unpaid late payments.
Order: by severity — 180 → 120 → 90 → 60 → 30.
→ Recorded as allocationBreakdown.lateSeverityPayment

Extra principal on credit cards:
Allocate remaining budget to the gap between current balance and already allocated payments on cards.
Order: (1) Annual-fee cards by APR (tiebreak earlier due day),
       (2) CFA cards by APR (tiebreak earlier due day),
       (3) all other cards by APR (tiebreak earlier due day).
→ Recorded as allocationBreakdown.cardExtra

Collections:
Allocate next to collections originating from accounts (sentToCollections == true), highest amount first;
then to third-party collections (user_collections_3rd_party), highest amount first.
→ Recorded as allocationBreakdown.collections

This structure allocates the entire monthlyBudget unless all balances are fully covered,
in which case any remainder is left unallocated and all PAY actions are complete in the current month.
*/



const functions = require('firebase-functions');
const admin     = require('firebase-admin');
// FlutterFlow initializes admin

exports.writeAndComputePayPrioritiesList = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    if (!context.auth?.uid) {
      throw new functions.https.HttpsError('unauthenticated', 'Must be signed in.');
    }

    const db = admin.firestore();
    const uid = context.auth.uid;
    const userRef = db.doc(`users/${uid}`);

    const now = Date.now();
    const MS_PER_DAY = 24 * 60 * 60 * 1000;

    const asNum = (v, d=0) => Number.isFinite(Number(v)) ? Number(v) : d;
    const toTierFromDOFD = (dofdTs) => {
      if (!dofdTs) return 30;
      const t = dofdTs?.toDate ? dofdTs.toDate().getTime() : (dofdTs instanceof Date ? dofdTs.getTime() : 0);
      if (!t) return 30;
      const days = Math.max(0, Math.floor((now - t) / MS_PER_DAY));
      const raw  = Math.ceil(days / 30) * 30;
      return Math.min(180, Math.max(30, raw)); // 30..180
    };

    // ---------- Inputs ----------
    const monthlyBudget = asNum((await userRef.get()).get('monthly_budget'), 0);
    let budgetLeft = monthlyBudget;

    // Discover current stocks from conso (exclude hard pulls)
    const consoSnap = await db.collection('user_stocks_conso')
      .where('userRef','==', userRef).get();

    const conso = consoSnap.docs
      .map(d => ({ id: d.id, ...d.data() }))
      .filter(d => d.stock !== 'user_hard_pulls');

    const cardIds = conso.filter(x => x.stock === 'user_credit_cards').map(x => x.id);
    const loanIds = conso.filter(x => x.stock === 'user_loans').map(x => x.id);

    // Pull origin docs (terms & balances come from origin)
    const [cardDocs, loanDocs] = await Promise.all([
      Promise.all(cardIds.map(id => db.collection('user_credit_cards').doc(id).get())),
      Promise.all(loanIds.map(id => db.collection('user_loans').doc(id).get()))
    ]);
    const cardsMap = {};
    cardDocs.forEach(s => { if (s.exists) cardsMap[s.id] = { id: s.id, ref: s.ref, ...s.data() }; });
    const loansMap = {};
    loanDocs.forEach(s => { if (s.exists) loansMap[s.id] = { id: s.id, ref: s.ref, ...s.data() }; });

    // Late payments (origin, unpaid only)
    const [lateCardsSnap, lateLoansSnap] = await Promise.all([
      db.collection('user_credit_cards_late_payments').where('userRef','==', userRef).where('isPaid','==', false).get(),
      db.collection('user_loans_late_payments').where('userRef','==', userRef).where('isPaid','==', false).get()
    ]);
    const lateItems = [
      ...lateCardsSnap.docs.map(d => ({ id: d.id, ref: d.ref, kind: 'cardLate', ...d.data() })),
      ...lateLoansSnap.docs.map(d => ({ id: d.id, ref: d.ref, kind: 'loanLate', ...d.data() }))
    ];

    // --- also fetch origin accounts referenced by late docs (cardRef/loanRef) ---
    const keyForRef = (r) => r ? `${r.parent.id}/${r.id}` : '';
    const lateAccountRefSet = new Set();
    lateItems.forEach(L => {
      if (L.cardRef) lateAccountRefSet.add(keyForRef(L.cardRef));
      if (L.loanRef) lateAccountRefSet.add(keyForRef(L.loanRef));
    });
    const lateAccountRefs = [...lateAccountRefSet].map(k => {
      const [col, id] = k.split('/');
      return db.collection(col).doc(id);
    });
    const lateAccountDocs = await Promise.all(lateAccountRefs.map(r => r.get()));
    const lateAccMap = {};
    lateAccountDocs.forEach(s => {
      if (s.exists) {
        const col = s.ref.parent.id; // user_credit_cards or user_loans
        lateAccMap[keyForRef(s.ref)] = { id: s.id, ref: s.ref, collection: col, ...s.data() };
      }
    });

    // 3rd-party collections (unpaid)
    const tpcSnap = await db.collection('user_collections_3rd_party')
      .where('userRef','==', userRef).where('isPaid','==', false).get();
    const tpcItems = tpcSnap.docs.map(d => ({ id: d.id, ref: d.ref, ...d.data() }));

    // ---------- Build working rows ----------
    const items = [];

    // Accounts (cards + loans)
    conso.forEach(src => {
      if (src.stock !== 'user_credit_cards' && src.stock !== 'user_loans') return;

      const isCard = src.stock === 'user_credit_cards';
      const o = isCard ? cardsMap[src.id] : loansMap[src.id];
      if (!o) return;

      const apr        = asNum(o.apr, 0);
      const minPayment = isCard ? asNum(o.minimumPayment, 0) : asNum(o.monthlyPayment, 0);
      const balance    = isCard ? asNum(o.totalBalance, 0) : asNum(o.balance, 0);
      const dueDay     = asNum(o.dayOfMonthDue ?? null, null);

      // flags for Step 3 grouping (from conso flags)
      const isAnnualFee = !!src.isAnnualFee;
      const isCFA       = !!src.isCFA;

      items.push({
        kind: 'account',
        id: src.id,
        stock: src.stock,
        name: o.commercialName ?? src.name ?? null,
        lender: o.lender ?? src.lender ?? null,
        sourceRef: o.ref, // origin doc ref
        apr,
        minPayment,
        balance,
        dueDay,
        isAnnualFee, // used only for grouping in Step 3
        isCFA,       // used only for grouping in Step 3
        alloc_total: 0,
        alloc_min: 0,
        alloc_card_extra: 0,
      });
    });

    // Unpaid lates (some may be sentToCollections) — use origin account's lender/name via cardRef/loanRef
    lateItems.forEach(L => {
      const severity = toTierFromDOFD(L.DOFD); // numeric tier 30..180
      const sentToCollections = !!L.sentToCollections;
      const amount = asNum(L.amount, 0);

      const originRefKey = L.cardRef ? keyForRef(L.cardRef) : L.loanRef ? keyForRef(L.loanRef) : '';
      const originAcc = originRefKey ? lateAccMap[originRefKey] : null;

      const lender = originAcc?.lender ?? L.lender ?? null;
      const name   = originAcc?.commercialName ?? L.name ?? null;

      items.push({
        kind: sentToCollections ? 'collection_from_account' : 'late',
        id: L.id,
        stock: L.kind === 'cardLate' ? 'user_credit_cards_late_payments' : 'user_loans_late_payments',
        name,
        lender,
        sourceRef: L.ref,
        severity,
        amount,
        alloc_total: 0,
        alloc_late: 0,
        alloc_collections: 0,
      });
    });

    // Third-party collections
    tpcItems.forEach(C => {
      items.push({
        kind: 'collection_third_party',
        id: C.id,
        stock: 'user_collections_3rd_party',
        name: C.originalProvider ?? C.collectionsAgency ?? C.type ?? null,
        lender: C.collectionsAgency ?? null,
        sourceRef: C.ref,
        amount: asNum(C.amount, 0),
        alloc_total: 0,
        alloc_collections: 0,
      });
    });

    // ---------- Allocation ----------

    // 1) Minimum monthly payments (cards + loans)
    const accounts = items.filter(i => i.kind === 'account');
    const totalMin = accounts.reduce((s,i) => s + i.minPayment, 0);

    if (budgetLeft > 0) {
      if (budgetLeft >= totalMin) {
        accounts
          .sort((a,b) => (b.apr - a.apr) || ((a.dueDay ?? 32) - (b.dueDay ?? 32)))
          .forEach(i => {
            const pay = i.minPayment;
            const alloc = Math.min(budgetLeft, pay);
            i.alloc_min += alloc;
            i.alloc_total += alloc;
            budgetLeft -= alloc;
          });
      } else {
        // Pro-rata by pressure = minPayment × APR ; tie-break earlier due day
        const weights = accounts.map(i => ({
          id: i.id,
          w: Math.max(0, i.minPayment * (i.apr / 100)),
          dueDay: i.dueDay
        }));
        const sumW = weights.reduce((s,x)=>s+x.w,0);
        weights.sort((a,b) => (b.w - a.w) || ((a.dueDay ?? 32) - (b.dueDay ?? 32)));

        let remaining = budgetLeft;
        for (const w of weights) {
          const it = accounts.find(z => z.id === w.id);
          if (!it) continue;
          const target = sumW > 0 ? (w.w / sumW) * budgetLeft : 0;
          const pay = Math.min(remaining, Math.max(0, target));
          it.alloc_min += pay;
          it.alloc_total += pay;
          remaining -= pay;
        }
        budgetLeft = Math.max(0, remaining);

        // Sweep any rounding remainder in sort order up to the item’s min
        for (const w of weights) {
          if (budgetLeft <= 0) break;
          const it = accounts.find(z => z.id === w.id);
          const delta = Math.min(budgetLeft, Math.max(0, it.minPayment - it.alloc_min));
          if (delta > 0) {
            it.alloc_min += delta;
            it.alloc_total += delta;
            budgetLeft -= delta;
          }
        }
      }
    }

    // 2) Unpaid lates by severity (180 → 30)
    items
      .filter(i => i.kind === 'late')
      .sort((a,b) => (b.severity || 0) - (a.severity || 0))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const need = i.amount - i.alloc_total;
        if (need <= 0) return;
        const pay = Math.min(budgetLeft, need);
        i.alloc_late += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    // 3) Card extra principal — AF first, then CFA, then others (APR desc, earlier due day)
    const byAprThenDue = (a,b) => (b.apr - a.apr) || ((a.dueDay ?? 32) - (b.dueDay ?? 32));
    const cardsAF   = items.filter(a => a.kind==='account' && a.stock==='user_credit_cards' && a.isAnnualFee);
    const cardsCFA  = items.filter(a => a.kind==='account' && a.stock==='user_credit_cards' && !a.isAnnualFee && a.isCFA);
    const cardsRest = items.filter(a => a.kind==='account' && a.stock==='user_credit_cards' && !a.isAnnualFee && !a.isCFA);

    ;[cardsAF, cardsCFA, cardsRest].forEach(group => {
      group.sort(byAprThenDue).forEach(i => {
        if (budgetLeft <= 0) return;
        const remaining = Math.max(0, i.balance - i.alloc_total);
        if (remaining <= 0) return;
        const pay = Math.min(budgetLeft, remaining);
        i.alloc_card_extra += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });
    });

    // 4) Collections — account-origin (sentToCollections), then third-party
    items
      .filter(i => i.kind === 'collection_from_account')
      .sort((a,b) => (b.amount||0) - (a.amount||0))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const need = i.amount - i.alloc_total;
        if (need <= 0) return;
        const pay = Math.min(budgetLeft, need);
        i.alloc_collections += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    items
      .filter(i => i.kind === 'collection_third_party')
      .sort((a,b) => (b.amount||0) - (a.amount||0))
      .forEach(i => {
        if (budgetLeft <= 0) return;
        const need = i.amount - i.alloc_total;
        if (need <= 0) return;
        const pay = Math.min(budgetLeft, need);
        i.alloc_collections += pay;
        i.alloc_total += pay;
        budgetLeft -= pay;
      });

    // ---------- Persist (delta-aware; write only new/changed) ----------
    const priorityKey = (i) => (
      i.kind === 'account' && i.alloc_min > 0 ? 1 :
      i.kind === 'late'    && i.alloc_total > 0 ? 2 :
      i.kind === 'account' && i.alloc_card_extra > 0 ? 3 :
      (i.kind === 'collection_from_account' || i.kind === 'collection_third_party') && i.alloc_total > 0 ? 4 : 5
    );

    const ranked = [...items].sort((a,b) => {
      const pa = priorityKey(a), pb = priorityKey(b);
      if (pa !== pb) return pa - pb;
      return (b.alloc_total||0) - (a.alloc_total||0);
    });

    const existingSnap = await db.collection('user_pay_priority_list')
      .where('userRef', '==', userRef).get();

    // Build a minimal previous map limited to fields we write
    const pickRelevant = (x) => {
      if (!x) return null;
      const base = {
        userRef: x.userRef,
        rank: x.rank,
        monthlyBudget: x.monthlyBudget,
        availableRemainder: x.availableRemainder,
        stockType: x.stockType,
        name: x.name,
        lender: x.lender,
      };
      if (x.stockType === 'user_credit_cards' || x.stockType === 'user_loans') {
        return {
          ...base,
          originDocRef: x.originDocRef || null,
          apr: x.apr,
          balance: x.balance,
          minPayment: x.minPayment,
          dayOfMonthDue: x.dayOfMonthDue ?? null,
          budgetAllocated: x.budgetAllocated,
          allocationBreakdown: x.allocationBreakdown || {},
        };
      } else if (x.stockType === 'user_credit_cards_late_payments' || x.stockType === 'user_loans_late_payments') {
        return {
          ...base,
          originDocRef: x.originDocRef || null,
          severity: x.severity,
          amount: x.amount,
          budgetAllocated: x.budgetAllocated,
          allocationBreakdown: x.allocationBreakdown || {},
        };
      } else { // collections
        return {
          ...base,
          originDocRef: x.originDocRef || null,
          amount: x.amount,
          budgetAllocated: x.budgetAllocated,
          allocationBreakdown: x.allocationBreakdown || {},
        };
      }
    };

    const existingMap = {};
    existingSnap.forEach(d => existingMap[d.id] = pickRelevant(d.data()));

    const currentIds = new Set(items.map(i => i.id));
    const batch = db.batch();

    // delete stale
    existingSnap.forEach(d => { if (!currentIds.has(d.id)) batch.delete(d.ref); });

    ranked.forEach((i, idx) => {
      const docRef = db.collection('user_pay_priority_list').doc(i.id);

      // Build FlutterFlow-friendly poly-ref object (only one field set)
      const originDocRef = (() => {
        if (i.kind === 'account' && i.stock === 'user_credit_cards') return { CardsDocRef: i.sourceRef };
        if (i.kind === 'account' && i.stock === 'user_loans')        return { LoansDocRef: i.sourceRef };
        if (i.kind === 'late' && i.stock === 'user_credit_cards_late_payments') return { CardLatesOrCollectionsDocRef: i.sourceRef };
        if (i.kind === 'late' && i.stock === 'user_loans_late_payments')        return { LoanLatesOrCollectionsDocRef: i.sourceRef };
        if (i.kind === 'collection_third_party') return { Collections3rdPartDocRef: i.sourceRef };
        if (i.kind === 'collection_from_account') {
          return i.stock === 'user_credit_cards_late_payments'
            ? { CardLatesOrCollectionsDocRef: i.sourceRef }
            : { LoanLatesOrCollectionsDocRef:  i.sourceRef };
        }
        return {};
      })();

      const base = {
        userRef,
        rank: idx + 1,
        monthlyBudget,
        availableRemainder: Number(budgetLeft.toFixed(2)),
        originDocRef, // DocRefMultiCollection custom object
      };

      let newData;

      if (i.kind === 'account') {
        const breakdown =
          i.stock === 'user_credit_cards'
            ? {
                minPayment: Number(i.alloc_min.toFixed(2)),
                cardExtra: Number(i.alloc_card_extra.toFixed(2)), // only for cards
              }
            : {
                minPayment: Number(i.alloc_min.toFixed(2)),       // loans: no cardExtra key
              };

        newData = {
          ...base,
          stockType: i.stock,
          name: i.name,
          lender: i.lender,
          apr: i.apr,
          balance: Number(i.balance.toFixed(2)),
          minPayment: Number(i.minPayment.toFixed(2)),
          dayOfMonthDue: i.dueDay ?? null,
          budgetAllocated: Number(i.alloc_total.toFixed(2)),
          allocationBreakdown: breakdown,
        };
      } else if (i.kind === 'late') {
        newData = {
          ...base,
          stockType: i.stock,
          name: i.name,       // from origin account when available
          lender: i.lender,   // from origin account when available
          severity: i.severity,
          amount: Number(i.amount.toFixed(2)),
          budgetAllocated: Number(i.alloc_total.toFixed(2)),
          allocationBreakdown: {
            lateSeverityPayment: Number(i.alloc_late.toFixed(2)),
          },
        };
      } else {
        newData = {
          ...base,
          stockType: i.stock,
          name: i.name,
          lender: i.lender,
          amount: Number(i.amount.toFixed(2)),
          budgetAllocated: Number(i.alloc_total.toFixed(2)),
          allocationBreakdown: {
            collections: Number(i.alloc_collections.toFixed(2)),
          },
        };
      }

      const prevRelevant = existingMap[i.id];
      if (!prevRelevant || JSON.stringify(prevRelevant) !== JSON.stringify(newData)) {
        batch.set(docRef, newData, { merge: true });
      }
    });

    await batch.commit();
    return { success: true, count: items.length, availableRemainder: Number(budgetLeft.toFixed(2)) };
  });
