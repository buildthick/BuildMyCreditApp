//Ensures userRef included and computes value of concatKey `CountPayment HistoryRevolvingCredit CardCurrentNot applicable`
// this is just the field for current credit cards, and should be the highest of 2x installment accounts, 11, or 2x lates

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// To avoid deployment errors, do not call admin.initializeApp() in your code

exports.profileAuditTargetUserAndCountCurrentCCs = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    // 1. Auth check
    if (!context.auth || !context.auth.uid) {
      return;
    }

    const uid = context.auth.uid;
    const userRef = admin.firestore().collection('users').doc(uid);
    const targetsCol = admin.firestore().collection('profile_audit_targets');
    const KEY = 'CountPayment HistoryRevolvingCredit CardCurrentNot applicable';

    // 2. Compute the three candidate values
    // a) 2× count of open & current loans
    const openLoansSnap = await admin.firestore()
      .collection('user_loans')
      .where('isOpen', '==', true)
      .where('isCurrent', '==', true)
      .get();
    const val1 = openLoansSnap.size * 2;

    // b) constant 11
    const val2 = 11;

    // c) 2× count of non‐placeholder late payments (cards + loans)
    const ccLateSnap = await admin.firestore()
      .collection('user_credit_cards_late_payments')
      .where('isPlaceholder', '==', false)
      .get();
    const loansLateSnap = await admin.firestore()
      .collection('user_loans_late_payments')
      .where('isPlaceholder', '==', false)
      .get();
    const val3 = (ccLateSnap.size + loansLateSnap.size) * 2;

    // 3. Pick the highest
    const newTarget = Math.max(val1, val2, val3);

    // 4. Fetch all audit‐target docs & begin batch
    const snapshot = await targetsCol.get();
    const batch = admin.firestore().batch();

    snapshot.forEach(doc => {
      const d = doc.data();
      const ref = doc.ref;

      // — only set userRef if missing
      if (!d.userRef) {
        batch.update(ref, { userRef });
      }

      // — only update Target if this is our key AND the value has actually changed
      if (d.concatKey === KEY && d.Target !== newTarget) {
        batch.update(ref, { Target: newTarget });
      }
    });

    // 5. Commit and return
    await batch.commit();
    return { success: true, newTarget };
  });
