//This version includes offerLink so user may apply from app
// This version includes writing the docID = lender+name+randChar5

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// admin.initializeApp(); // already initialized elsewhere

// Helper to generate a 5-character alphanumeric string
function randomSuffix(length = 5) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

// Helper to slugify lender + name into a safe ID
function makeDocId(lender = '', name = '') {
  const base = `${lender}-${name}`
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')   // non-alphanumerics â†’ dash
    .replace(/^-+|-+$/g, '');      // trim leading/trailing dashes
  return `${base}-${randomSuffix()}`;
}

exports.cleanAndWriteUserCardRecs = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    if (!context.auth || !context.auth.uid) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'You must be logged in to perform this action.'
      );
    }

    const uid = context.auth.uid;
    const db = admin.firestore();
    const userRef = db.collection('users').doc(uid);
    const userSnap = await userRef.get();
    const userData = userSnap.data();

    const rewardPref = userData.card_reward_preference;
    if (!rewardPref) {
      throw new functions.https.HttpsError(
        'failed-precondition',
        'User does not have a card_reward_preference set.'
      );
    }

    const userCardsRef  = db.collection('user_card_recommendations');
    const offersCardsRef = db.collection('offers_cards');

    // 1) Fetch existing recommendations
    const existingSnap = await userCardsRef
      .where('userRef', '==', userRef)
      .get();

    const existingDocs = existingSnap.docs.map(doc => doc.data());

    // 2) Fetch offers_cards filtered by rewardType
    const offersSnap = await offersCardsRef
      .where('rewardType', '==', rewardPref)
      .get();
    const filteredOffers = offersSnap.docs.map(doc => doc.data());

    // 3) Normalize for comparison (strip transient fields)
    const cleanedExisting = existingDocs.map(doc => {
      const { isAccepted, dateAccepted, userRef, ...rest } = doc;
      return rest;
    });
    const cleanedOffers = filteredOffers.map(doc => {
      const { isAccepted, dateAccepted, ...rest } = doc;
      return rest;
    });

    const isEqual =
      cleanedExisting.length === cleanedOffers.length &&
      cleanedExisting.every(e =>
        cleanedOffers.some(o => JSON.stringify(o) === JSON.stringify(e))
      );
    if (isEqual) {
      console.log('No changes detected. Skipping write.');
      return { success: true, message: 'No changes detected.' };
    }

    // 4) Delete old docs and write new ones with custom IDs
    const batch = db.batch();
    existingSnap.forEach(doc => batch.delete(doc.ref));

    filteredOffers.forEach(offer => {
      // build a safe doc ID: lender + name + random suffix
      const docId = makeDocId(offer.lender, offer.commercialName);
      const newDocRef = userCardsRef.doc(docId);

      batch.set(
        newDocRef,
        {
          ...offer,
          offerLink: offer.offerLink ?? null,
          userRef
        },
        { merge: true }
      );
    });

    await batch.commit();

    return {
      success: true,
      message: 'User card recommendations reset.',
      deleted: existingDocs.length,
      written: filteredOffers.length,
    };
  });
