//This version includes offerLink so user may apply from app
// This version includes writing the docID = lender+name+rewardType

const functions = require('firebase-functions');
const admin = require('firebase-admin');
// admin.initializeApp(); // initialized elsewhere

// Helper to slugify rewardType + lender + name into a safe, stable ID
function makeDocId(rewardType = '', lender = '', name = '') {
  return `${rewardType}-${lender}-${name}`
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')   // non-alphanumerics â†’ dash
    .replace(/^-+|-+$/g, '');      // trim leading/trailing dashes
}

exports.cleanAndWriteUserCardRecs = functions
  .region('us-central1')
  .https.onCall(async (data, context) => {
    if (!context.auth?.uid) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'You must be logged in to perform this action.'
      );
    }

    const uid = context.auth.uid;
    const db = admin.firestore();
    const userRef = db.collection('users').doc(uid);
    const userSnap = await userRef.get();
    const rewardPref = userSnap.data()?.card_reward_preference;
    if (!rewardPref) {
      throw new functions.https.HttpsError(
        'failed-precondition',
        'User does not have a card_reward_preference set.'
      );
    }

    const userCardsRef  = db.collection('user_card_recommendations');
    const offersCardsRef = db.collection('offers_cards');

    // 1) Load existing recs
    const existingSnap = await userCardsRef
      .where('userRef','==', userRef)
      .get();
    const existingMap = {};
    existingSnap.docs.forEach(doc => {
      existingMap[doc.id] = doc.data();
    });
    const existingIds = new Set(Object.keys(existingMap));

    // 2) Load new offers
    const offersSnap = await offersCardsRef
      .where('rewardType','==', rewardPref)
      .get();
    const offersById = {};
    offersSnap.docs.forEach(doc => {
      const offer = doc.data();
      const id    = makeDocId(offer.rewardType, offer.lender, offer.commercialName);
      offersById[id] = offer;
    });
    const offerIds = new Set(Object.keys(offersById));

    // 3) Compute creates & deletes
    const toCreate = [...offerIds].filter(id => !existingIds.has(id));
    const toDelete = [...existingIds].filter(id => {
      const isInOffers = offerIds.has(id);
      const wasAccepted = existingMap[id].isAccepted === true;
      return !isInOffers && !wasAccepted;
    });

    // 4) Batch it
    const batch = db.batch();
    toDelete.forEach(id => batch.delete(userCardsRef.doc(id)));
    toCreate.forEach(id => {
      const offer = offersById[id];
      batch.set(
        userCardsRef.doc(id),
        {
          ...offer,
          offerLink:  offer.offerLink ?? null,
          userRef,
          isAccepted: false    // initialize to false so UI shows it
          // dateAccepted is left untouched if ever set
        },
        { merge: true }
      );
    });

    await batch.commit();

    return {
      success: true,
      deleted: toDelete.length,
      created: toCreate.length,
      kept:    existingIds.size - toDelete.length
    };
  });
